/*
 * Particle.cpp
 *
 *  Created on: 23.02.2010
 *      Author: eckhardw
 */

#include "Particle.h"

#include <iostream>
#include "utils/ArrayUtils.h"
#include "utils/MaxwellBoltzmannDistribution.h"


namespace md {

	/// -----------------------------------------
	/// \brief Particle Class Methods
	/// -----------------------------------------
	Particle::Particle(const int type):
		position({}),
		velocity({}),
		force({}),
		old_force({}),
		mass(0),
		type(type) {
		// std::cout << "Particle generated!" << std::endl;
	}

	Particle::Particle(const vec3& position, const vec3& velocity, const double mass, const int type)
		: position(position), velocity(velocity), force({}), old_force({}), mass(mass), type(type) {
		// std::cout << "Particle generated by copy!" << std::endl;
	}

	Particle::Particle(const Particle& other)
		: position(other.position), velocity(other.velocity), force(other.force),
		  old_force(other.old_force), mass(other.mass), type(other.type) {
		std::cout << "Particle generated by copy!" << std::endl;
	}

	Particle::~Particle() {
		// std::cout << "Particle destructed!" << std::endl;
	}

	std::string Particle::to_string() const {
		std::stringstream stream;
		using ::operator<<;
		stream << "Particle: X:" << position << " v: " << velocity << " f: " << force
			<< " old_f: " << old_force << " type: " << type;
		return stream.str();
	}

	bool Particle::operator==(const Particle& other) const {
		return position == other.position &&
			velocity == other.velocity &&
			force == other.force &&
			old_force == other.old_force &&
			mass == other.mass &&
			type == other.type;
	}

	std::ostream& operator<<(std::ostream& stream, Particle& p) {
		stream << p.to_string();
		return stream;
	}


	/// -----------------------------------------
	/// \brief ParticleContainer Class Methods
	/// -----------------------------------------
	ParticleContainer::ParticleContainer(const std::vector<Particle>& particles):
		particles(particles) {}

	size_t ParticleContainer::size() const {
		return particles.size();
	}

	Particle& ParticleContainer::operator[](const size_t index) {
		return particles[index];
	}

	const Particle& ParticleContainer::operator[](const size_t index) const {
		return particles[index];
	}

	ParticleContainer ParticleContainer::operator+(const ParticleContainer& other) const {
		ParticleContainer result(*this);
		result.particles.insert(result.particles.end(), other.particles.begin(), other.particles.end());
		return result;
	}


	/// -----------------------------------------
	/// \brief ParticleCuboid Class Methods
	/// -----------------------------------------
	ParticleCuboid::ParticleCuboid(const vec3& origin, const std::array<u_int32_t, 3> num_particles, const double width, double mass,
	                               const double avg_velocity, int type): ParticleContainer()
	{

		particles.reserve(num_particles[0] * num_particles[1] * num_particles[2]);

		for (int x = 0; x < num_particles[0]; ++x) {
			for (int y = 0; y < num_particles[1]; ++y) {
				for (int z = 0; z < num_particles[2]; ++z) {
					vec3 pos = origin + vec3({
						x*width,y*width,z*width
					});

					vec3 vel = maxwellBoltzmannDistributedVelocity(avg_velocity, 3);

					particles.emplace_back(pos, vel, mass, type);
				}
			}
		}
	}
}

