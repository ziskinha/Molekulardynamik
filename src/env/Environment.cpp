
#include <ranges>

#include "Environment.h"
#include "io/Logger.h"
#include "utils/ArrayUtils.h"
#include "utils/MaxwellBoltzmannDistribution.h"

#define WARN_IF_INIT(msg) \
    do { \
        if (initialized) { \
        SPDLOG_WARN("You are trying to {} in an initialized environment. Request will be ignored",  msg);\
        return; \
        } \
    }while (0)

# define DOUBLE_MIN std::numeric_limits<double>::min()
# define DOUBLE_MAX std::numeric_limits<double>::max()
# define MIN_VEC3 vec3{DOUBLE_MIN, DOUBLE_MIN, DOUBLE_MIN}
# define MAX_VEC3 vec3{DOUBLE_MAX, DOUBLE_MAX, DOUBLE_MAX}
# define OUTSIDE_CELL int3{-1,-1,-1}

namespace md {
    int GridCell::count = 0;


    /// -----------------------------------------
    /// \brief CreateInfo Constructors
    /// -----------------------------------------
    ParticleCreateInfo::ParticleCreateInfo(const vec3& position, const vec3& velocity, const double mass,
                                           const int type)
        : position(position), velocity(velocity), mass(mass), type(type) {}


    CuboidCreateInfo::CuboidCreateInfo(const vec3& origin, const vec3& initial_v, const uint3& num_particles,
                                       const double thermal_v,
                                       const double width, const double mass, const uint8_t dimension, const int type)
        : origin(origin),
          initial_v(initial_v),
          num_particles(num_particles),
          thermal_v(thermal_v),
          width(width),
          mass(mass),
          dimension(dimension),
          type(type) {}


    /// -----------------------------------------
    /// \brief Particle Class Methods
    /// -----------------------------------------
    Particle::Particle(const size_t id, ParticleGrid& grid, const vec3& position, const vec3& velocity, const double mass, const int type)
        : position(position), velocity(velocity), force(), old_force(), cell(), mass(mass), type(type), id(id),
          grid(grid) {
        SPDLOG_TRACE("Particle generated!");
    }

    Particle::Particle(const Particle& other)
        : position(other.position),
          velocity(other.velocity),
          force(other.force),
          old_force(other.old_force),
          cell(other.cell),
          mass(other.mass),
          type(other.type),
          id(other.id),
          grid(other.grid) {
        SPDLOG_TRACE("Particle generated by copy!");
    }

    void Particle::reset_force() {
        old_force = force;
        force = {0, 0, 0};
    }

    void Particle::update_grid() {
        grid.update_cells(this, cell, grid.what_cell(position));
        cell = grid.what_cell(position);
    }

    std::string Particle::to_string() const {
        std::stringstream stream;
        using ::operator<<;
        stream << "Particle: X:" << position << " v: " << velocity << " f: " << force << " old_f: " << old_force
            << " type: " << type;
        return stream.str();
    }

    bool Particle::operator==(const Particle& other) const {
        return position == other.position && velocity == other.velocity && force == other.force &&
               old_force == other.old_force && mass == other.mass && type == other.type;
    }


    /// -----------------------------------------
    /// \brief Grid Class Methods
    /// -----------------------------------------
    GridCell::GridCell(const vec3& coord, const vec3& size, const Type type)
        : coordinate(coord), size(size), type(type), id(count++) {}

    std::string GridCell::to_string() const {
        std::stringstream stream;
        using ::operator<<;
        stream << "origin:" << coordinate << " size: " << size << " type: " << type << " Particles: " << particles.
            size();
        return stream.str();
    }


    void ParticleGrid::build(const vec3 & extent, const double grid_const, std::vector<Particle>& particles) {
        // TODO parameter checking

        build_cells(extent, grid_const, particles);
        build_cell_pairs();

    }

    void ParticleGrid::build_cells(const vec3 & extent, const double grid_const, std::vector<Particle>& particles) {
        grid_constant = grid_const;

        // number of cells along each axis
        const auto num_x = static_cast<UINT_T>(ceil(extent[0] / grid_constant));
        const auto num_y = static_cast<UINT_T>(ceil(extent[1] / grid_constant));
        const auto num_z = static_cast<UINT_T>(ceil(extent[2] / grid_constant));
        cell_count = uint3{num_x, num_y, num_z};

        // create cells
        for (size_t x = 0; x < num_x; x++) {
            for (size_t y = 0; y < num_y; y++) {
                for (size_t z = 0; z < num_z; z++) {
                    auto type = GridCell::INNER;
                    vec3 size = {grid_constant, grid_constant, grid_constant};

                    // TODO rather extend or shrink cell size to have uniform size
                    // cells at the boundaries my need to be truncated
                    if (x == num_x - 1 && std::fmod(extent[0], grid_constant) != 0)
                        size[0] = std::fmod(extent[0], grid_constant);
                    if (y == num_y - 1 && std::fmod(extent[1], grid_constant) != 0)
                        size[1] = std::fmod(extent[1], grid_constant);
                    if (z == num_z - 1 && std::fmod(extent[2], grid_constant) != 0)
                        size[2] = std::fmod(extent[2], grid_constant);
                    if (x == 0 || y == 0 || z == 0 || x == num_x - 1 || y == num_y - 1 || z == num_z - 1)
                        type = GridCell::BOUNDARY;

                    GridCell cell = {{grid_constant * static_cast<double>(x),
                                      grid_constant * static_cast<double>(y),
                                      grid_constant * static_cast<double>(z)},
                                     size, type};

                    int3 idx = {static_cast<int64_t>(x), static_cast<int64_t>(y), static_cast<int64_t>(z)};
                    cells.emplace(idx, cell);

                    SPDLOG_TRACE("Grid Cell created. index: {} Cell: {}", idx, cell.to_string());
                }
            }
        }

        // create a cell representing the "outside"
        GridCell outside = {MIN_VEC3, MAX_VEC3, GridCell::OUTER};
        cells.emplace(OUTSIDE_CELL, outside);
        SPDLOG_TRACE("Grid Cell created. index: {} Cell: {}", OUTSIDE_CELL, outside.to_string());

        // fill cells with particles
        for (auto& p : particles) {
            int3 idx = what_cell(p.position);
            cells.at(idx).particles.emplace(&p);
            SPDLOG_TRACE("Particle of type {} at position {} added to Cell {}", p.type, p.position, idx);
        }
    }
    void ParticleGrid::build_cell_pairs() {

    }

    const GridCell& ParticleGrid::get_cell(const int3& idx) const {
        return cells.at(idx);
    }

    const GridCell& ParticleGrid::get_cell(const Particle& particle) const {
        return cells.at(what_cell(particle.position));
    }

    GridCell& ParticleGrid::get_cell(const int3& idx) {
        return cells.at(idx);
    }

    GridCell& ParticleGrid::get_cell(const Particle& particle) {
        return cells.at(what_cell(particle.position));
    }

    int3 ParticleGrid::what_cell(const vec3& pos) const {
        // boundary is axis aligned
        if (pos[0] < 0 || pos[1] < 0 || pos[2] < 0) {
            return OUTSIDE_CELL;
        }

        const auto x = static_cast<INT_T>(pos[0] / grid_constant);
        const auto y = static_cast<INT_T>(pos[1] / grid_constant);
        const auto z = static_cast<INT_T>(pos[2] / grid_constant);

        if (x >= cell_count[0] || y >= cell_count[1] || z >= cell_count[2]) {
            return OUTSIDE_CELL;
        }

        return int3{x, y, z};
    }

    std::vector<int3> ParticleGrid::get_cell_indices() const {
        std::vector<int3> keys;
        for (const auto& key : cells | std::views::keys) {
            keys.push_back(key);
        }
        return keys;
    }

    void ParticleGrid::update_cells(Particle* particle, const int3& old_cell, const int3& new_cell) {
        if (old_cell != new_cell) {
            auto& old = cells.at(old_cell);
            auto& current = cells.at(new_cell);

            old.particles.erase(particle);
            current.particles.insert(particle);

            // particle->type = current.id;

            SPDLOG_TRACE("Particle at {} changed cells from {} to {}", particle->position, old_cell, new_cell);
        }
    }


    /// -----------------------------------------
    /// \brief System Class Methods
    /// -----------------------------------------
    Environment::Environment()
        : grid_constant(std::numeric_limits<double>::max()), initialized(false) {}

    void Environment::set_force(const Force& force) {
        WARN_IF_INIT("set the force");
        this->force_func = force;
    }

    void Environment::set_force_cutoff(double cutoff_radius) {

    }

    void Environment::set_grid_constant(const double g) {
        WARN_IF_INIT("set the grid_constant");
        this->grid_constant = g;
    }

    void Environment::set_boundary(const Boundary& boundary) {
        WARN_IF_INIT("set the boundary");
        this->boundary = boundary;
    }

    void Environment::add_particle(const vec3& position, const vec3& velocity, double mass, int type) {
        WARN_IF_INIT("add particles");
        particle_storage.emplace_back(particle_storage.size(), grid, position, velocity, mass, type);
    }

    void Environment::add_particles(const std::vector<ParticleCreateInfo>& particles) {
        for (auto& x : particles) {
            add_particle(x.position, x.velocity, x.mass, x.type);
        }
    }

    void Environment::add_cuboid(const vec3& origin, const vec3& initial_v, const uint3& num_particles,
                                 const double thermal_v, const double width, const double mass, uint8_t const dimension,
                                 const int type) {
        WARN_IF_INIT("add particles (cuboids)");

        particle_storage.reserve(particle_storage.size() + num_particles[0] + num_particles[1] + num_particles[2]);

        for (unsigned int x = 0; x < num_particles[0]; ++x) {
            for (unsigned int y = 0; y < num_particles[1]; ++y) {
                for (unsigned int z = 0; z < num_particles[2]; ++z) {
                    vec3 pos = origin + vec3({x * width, y * width, z * width});
                    vec3 vel = initial_v + maxwellBoltzmannDistributedVelocity(thermal_v, dimension);
                    add_particle(pos, vel, mass, type);
                }
            }
        }
    }

    void Environment::add_cuboid(const CuboidCreateInfo& cuboid) {
        add_cuboid(cuboid.origin, cuboid.initial_v, cuboid.num_particles, cuboid.thermal_v, cuboid.width, cuboid.mass,
                   cuboid.dimension, cuboid.type);
    }

    void Environment::build() {
        // TODO check parameters
        grid.build(boundary.extent, grid_constant, particle_storage);
        initialized = true;
    }

    vec3 Environment::force(const Particle& p1, const Particle& p2) const {
        return force_func(p1, p2);
    }

    size_t Environment::size(Particle::State) const {
        return particle_storage.size();
    }

    Particle& Environment::operator[](const size_t id) {
        return particle_storage[id];
    }

    const Particle& Environment::operator[](const size_t id) const {
        return particle_storage[id];
    }

    bool Environment::filter_particles(const Particle& particle, const Particle::State state,
                                       const GridCell::Type type) const {
        const bool state_ok = (particle.type == PARTICLE_TYPE_DEAD && state & Particle::DEAD) ||
                              (particle.type < 0 && state & Particle::STATIONARY) ||
                              (particle.type >= 0 && particle.type != PARTICLE_TYPE_DEAD && state & Particle::ALIVE);
        const bool location_ok = grid.get_cell(particle).type & type;
        return state_ok && location_ok;
    }
} // namespace md
