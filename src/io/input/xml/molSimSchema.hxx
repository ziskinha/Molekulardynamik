// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MOL_SIM_SCHEMA_HXX
#define MOL_SIM_SCHEMA_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class Vec3Type_base;
class Vec3Type;
class Int3Type_base;
class Int3Type;
class DimensionType;
class ForceType;
class ConstantForceType;
class BoundaryType;
class ParticleStateType;
class ParallelType;
class Force;
class ConstantForce;
class Boundary;
class simulation;
class output;
class parameters;
class Forces;
class ConstantForces;
class Thermostat;
class particles;
class cuboids;
class spheres;
class membranes;
class statistics;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class Vec3Type_base: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  Vec3Type_base ();

  Vec3Type_base (size_type n, const ::xml_schema::double_& x);

  template < typename I >
  Vec3Type_base (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (begin, end, this)
  {
  }

  Vec3Type_base (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Vec3Type_base (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Vec3Type_base (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Vec3Type_base (const Vec3Type_base& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual Vec3Type_base*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Vec3Type_base ();
};

class Vec3Type: public ::Vec3Type_base
{
  public:
  // Constructors.
  //
  Vec3Type ();

  Vec3Type (const ::Vec3Type_base&);

  Vec3Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Vec3Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Vec3Type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Vec3Type (const Vec3Type& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Vec3Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Vec3Type ();
};

class Int3Type_base: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::int_, char >
{
  public:
  Int3Type_base ();

  Int3Type_base (size_type n, const ::xml_schema::int_& x);

  template < typename I >
  Int3Type_base (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (begin, end, this)
  {
  }

  Int3Type_base (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Int3Type_base (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Int3Type_base (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  Int3Type_base (const Int3Type_base& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual Int3Type_base*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Int3Type_base ();
};

class Int3Type: public ::Int3Type_base
{
  public:
  // Constructors.
  //
  Int3Type ();

  Int3Type (const ::Int3Type_base&);

  Int3Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Int3Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Int3Type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Int3Type (const Int3Type& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Int3Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Int3Type ();
};

class DimensionType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
{
  public:
  DimensionType (::xml_schema::int_ v);

  DimensionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  DimensionType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  DimensionType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  DimensionType (const DimensionType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual DimensionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class ForceType: public ::xml_schema::string
{
  public:
  enum value
  {
    lennardJones,
    inverseSquare
  };

  ForceType (value v);

  ForceType (const char* v);

  ForceType (const ::std::string& v);

  ForceType (const ::xml_schema::string& v);

  ForceType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ForceType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ForceType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ForceType (const ForceType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual ForceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ForceType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ForceType_convert ();
  }

  protected:
  value
  _xsd_ForceType_convert () const;

  public:
  static const char* const _xsd_ForceType_literals_[2];
  static const value _xsd_ForceType_indexes_[2];
};

class ConstantForceType: public ::xml_schema::string
{
  public:
  enum value
  {
    gravity,
    pullForce
  };

  ConstantForceType (value v);

  ConstantForceType (const char* v);

  ConstantForceType (const ::std::string& v);

  ConstantForceType (const ::xml_schema::string& v);

  ConstantForceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ConstantForceType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ConstantForceType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ConstantForceType (const ConstantForceType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ConstantForceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ConstantForceType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ConstantForceType_convert ();
  }

  protected:
  value
  _xsd_ConstantForceType_convert () const;

  public:
  static const char* const _xsd_ConstantForceType_literals_[2];
  static const value _xsd_ConstantForceType_indexes_[2];
};

class BoundaryType: public ::xml_schema::string
{
  public:
  enum value
  {
    OUTFLOW,
    VELOCITY_REFLECTION,
    REPULSIVE_FORCE,
    PERIODIC
  };

  BoundaryType (value v);

  BoundaryType (const char* v);

  BoundaryType (const ::std::string& v);

  BoundaryType (const ::xml_schema::string& v);

  BoundaryType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoundaryType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoundaryType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoundaryType (const BoundaryType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual BoundaryType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BoundaryType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_BoundaryType_convert ();
  }

  protected:
  value
  _xsd_BoundaryType_convert () const;

  public:
  static const char* const _xsd_BoundaryType_literals_[4];
  static const value _xsd_BoundaryType_indexes_[4];
};

class ParticleStateType: public ::xml_schema::string
{
  public:
  enum value
  {
    ALIVE,
    STATIONARY
  };

  ParticleStateType (value v);

  ParticleStateType (const char* v);

  ParticleStateType (const ::std::string& v);

  ParticleStateType (const ::xml_schema::string& v);

  ParticleStateType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ParticleStateType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ParticleStateType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ParticleStateType (const ParticleStateType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ParticleStateType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParticleStateType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ParticleStateType_convert ();
  }

  protected:
  value
  _xsd_ParticleStateType_convert () const;

  public:
  static const char* const _xsd_ParticleStateType_literals_[2];
  static const value _xsd_ParticleStateType_indexes_[2];
};

class ParallelType: public ::xml_schema::string
{
  public:
  enum value
  {
    NONE,
    CELL_LOCK,
    SPATIAL_DECOMPOSITION
  };

  ParallelType (value v);

  ParallelType (const char* v);

  ParallelType (const ::std::string& v);

  ParallelType (const ::xml_schema::string& v);

  ParallelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ParallelType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ParallelType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ParallelType (const ParallelType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual ParallelType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParallelType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ParallelType_convert ();
  }

  protected:
  value
  _xsd_ParallelType_convert () const;

  public:
  static const char* const _xsd_ParallelType_literals_[3];
  static const value _xsd_ParallelType_indexes_[3];
};

class Force: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::ForceType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // partType
  //
  typedef ::xml_schema::int_ partType_type;
  typedef ::xsd::cxx::tree::traits< partType_type, char > partType_traits;

  const partType_type&
  partType () const;

  partType_type&
  partType ();

  void
  partType (const partType_type& x);

  // arg1
  //
  typedef ::xml_schema::double_ arg1_type;
  typedef ::xsd::cxx::tree::optional< arg1_type > arg1_optional;
  typedef ::xsd::cxx::tree::traits< arg1_type, char, ::xsd::cxx::tree::schema_type::double_ > arg1_traits;

  const arg1_optional&
  arg1 () const;

  arg1_optional&
  arg1 ();

  void
  arg1 (const arg1_type& x);

  void
  arg1 (const arg1_optional& x);

  // arg2
  //
  typedef ::xml_schema::double_ arg2_type;
  typedef ::xsd::cxx::tree::optional< arg2_type > arg2_optional;
  typedef ::xsd::cxx::tree::traits< arg2_type, char, ::xsd::cxx::tree::schema_type::double_ > arg2_traits;

  const arg2_optional&
  arg2 () const;

  arg2_optional&
  arg2 ();

  void
  arg2 (const arg2_type& x);

  void
  arg2 (const arg2_optional& x);

  // Constructors.
  //
  Force (const type_type&,
         const partType_type&);

  Force (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Force (const Force& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Force*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Force&
  operator= (const Force& x);

  virtual 
  ~Force ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< partType_type > partType_;
  arg1_optional arg1_;
  arg2_optional arg2_;
};

class ConstantForce: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::ConstantForceType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // direction
  //
  typedef ::Vec3Type direction_type;
  typedef ::xsd::cxx::tree::traits< direction_type, char > direction_traits;

  const direction_type&
  direction () const;

  direction_type&
  direction ();

  void
  direction (const direction_type& x);

  void
  direction (::std::auto_ptr< direction_type > p);

  // strength
  //
  typedef ::xml_schema::double_ strength_type;
  typedef ::xsd::cxx::tree::traits< strength_type, char, ::xsd::cxx::tree::schema_type::double_ > strength_traits;

  const strength_type&
  strength () const;

  strength_type&
  strength ();

  void
  strength (const strength_type& x);

  // MarkBoxVec1
  //
  typedef ::Vec3Type MarkBoxVec1_type;
  typedef ::xsd::cxx::tree::optional< MarkBoxVec1_type > MarkBoxVec1_optional;
  typedef ::xsd::cxx::tree::traits< MarkBoxVec1_type, char > MarkBoxVec1_traits;

  const MarkBoxVec1_optional&
  MarkBoxVec1 () const;

  MarkBoxVec1_optional&
  MarkBoxVec1 ();

  void
  MarkBoxVec1 (const MarkBoxVec1_type& x);

  void
  MarkBoxVec1 (const MarkBoxVec1_optional& x);

  void
  MarkBoxVec1 (::std::auto_ptr< MarkBoxVec1_type > p);

  // MarkBoxVec2
  //
  typedef ::Vec3Type MarkBoxVec2_type;
  typedef ::xsd::cxx::tree::optional< MarkBoxVec2_type > MarkBoxVec2_optional;
  typedef ::xsd::cxx::tree::traits< MarkBoxVec2_type, char > MarkBoxVec2_traits;

  const MarkBoxVec2_optional&
  MarkBoxVec2 () const;

  MarkBoxVec2_optional&
  MarkBoxVec2 ();

  void
  MarkBoxVec2 (const MarkBoxVec2_type& x);

  void
  MarkBoxVec2 (const MarkBoxVec2_optional& x);

  void
  MarkBoxVec2 (::std::auto_ptr< MarkBoxVec2_type > p);

  // start_t
  //
  typedef ::xml_schema::double_ start_t_type;
  typedef ::xsd::cxx::tree::traits< start_t_type, char, ::xsd::cxx::tree::schema_type::double_ > start_t_traits;

  const start_t_type&
  start_t () const;

  start_t_type&
  start_t ();

  void
  start_t (const start_t_type& x);

  static start_t_type
  start_t_default_value ();

  // end_t
  //
  typedef ::xml_schema::double_ end_t_type;
  typedef ::xsd::cxx::tree::traits< end_t_type, char, ::xsd::cxx::tree::schema_type::double_ > end_t_traits;

  const end_t_type&
  end_t () const;

  end_t_type&
  end_t ();

  void
  end_t (const end_t_type& x);

  static end_t_type
  end_t_default_value ();

  // const_acc
  //
  typedef ::xml_schema::boolean const_acc_type;
  typedef ::xsd::cxx::tree::traits< const_acc_type, char > const_acc_traits;

  const const_acc_type&
  const_acc () const;

  const_acc_type&
  const_acc ();

  void
  const_acc (const const_acc_type& x);

  static const_acc_type
  const_acc_default_value ();

  // Constructors.
  //
  ConstantForce (const type_type&,
                 const direction_type&,
                 const strength_type&);

  ConstantForce (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ConstantForce (const ConstantForce& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual ConstantForce*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ConstantForce&
  operator= (const ConstantForce& x);

  virtual 
  ~ConstantForce ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< direction_type > direction_;
  ::xsd::cxx::tree::one< strength_type > strength_;
  MarkBoxVec1_optional MarkBoxVec1_;
  MarkBoxVec2_optional MarkBoxVec2_;
  ::xsd::cxx::tree::one< start_t_type > start_t_;
  ::xsd::cxx::tree::one< end_t_type > end_t_;
  ::xsd::cxx::tree::one< const_acc_type > const_acc_;
};

class Boundary: public ::xml_schema::type
{
  public:
  // typeLEFT
  //
  typedef ::BoundaryType typeLEFT_type;
  typedef ::xsd::cxx::tree::traits< typeLEFT_type, char > typeLEFT_traits;

  const typeLEFT_type&
  typeLEFT () const;

  typeLEFT_type&
  typeLEFT ();

  void
  typeLEFT (const typeLEFT_type& x);

  void
  typeLEFT (::std::auto_ptr< typeLEFT_type > p);

  // typeRIGHT
  //
  typedef ::BoundaryType typeRIGHT_type;
  typedef ::xsd::cxx::tree::traits< typeRIGHT_type, char > typeRIGHT_traits;

  const typeRIGHT_type&
  typeRIGHT () const;

  typeRIGHT_type&
  typeRIGHT ();

  void
  typeRIGHT (const typeRIGHT_type& x);

  void
  typeRIGHT (::std::auto_ptr< typeRIGHT_type > p);

  // typeTOP
  //
  typedef ::BoundaryType typeTOP_type;
  typedef ::xsd::cxx::tree::traits< typeTOP_type, char > typeTOP_traits;

  const typeTOP_type&
  typeTOP () const;

  typeTOP_type&
  typeTOP ();

  void
  typeTOP (const typeTOP_type& x);

  void
  typeTOP (::std::auto_ptr< typeTOP_type > p);

  // typeBOTTOM
  //
  typedef ::BoundaryType typeBOTTOM_type;
  typedef ::xsd::cxx::tree::traits< typeBOTTOM_type, char > typeBOTTOM_traits;

  const typeBOTTOM_type&
  typeBOTTOM () const;

  typeBOTTOM_type&
  typeBOTTOM ();

  void
  typeBOTTOM (const typeBOTTOM_type& x);

  void
  typeBOTTOM (::std::auto_ptr< typeBOTTOM_type > p);

  // typeFRONT
  //
  typedef ::BoundaryType typeFRONT_type;
  typedef ::xsd::cxx::tree::traits< typeFRONT_type, char > typeFRONT_traits;

  const typeFRONT_type&
  typeFRONT () const;

  typeFRONT_type&
  typeFRONT ();

  void
  typeFRONT (const typeFRONT_type& x);

  void
  typeFRONT (::std::auto_ptr< typeFRONT_type > p);

  // typeBACK
  //
  typedef ::BoundaryType typeBACK_type;
  typedef ::xsd::cxx::tree::traits< typeBACK_type, char > typeBACK_traits;

  const typeBACK_type&
  typeBACK () const;

  typeBACK_type&
  typeBACK ();

  void
  typeBACK (const typeBACK_type& x);

  void
  typeBACK (::std::auto_ptr< typeBACK_type > p);

  // origin
  //
  typedef ::Vec3Type origin_type;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_type&
  origin () const;

  origin_type&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // extent
  //
  typedef ::Vec3Type extent_type;
  typedef ::xsd::cxx::tree::traits< extent_type, char > extent_traits;

  const extent_type&
  extent () const;

  extent_type&
  extent ();

  void
  extent (const extent_type& x);

  void
  extent (::std::auto_ptr< extent_type > p);

  // grid_constant
  //
  typedef ::xml_schema::double_ grid_constant_type;
  typedef ::xsd::cxx::tree::traits< grid_constant_type, char, ::xsd::cxx::tree::schema_type::double_ > grid_constant_traits;

  const grid_constant_type&
  grid_constant () const;

  grid_constant_type&
  grid_constant ();

  void
  grid_constant (const grid_constant_type& x);

  // force_type
  //
  typedef ::ForceType force_type_type;
  typedef ::xsd::cxx::tree::optional< force_type_type > force_type_optional;
  typedef ::xsd::cxx::tree::traits< force_type_type, char > force_type_traits;

  const force_type_optional&
  force_type () const;

  force_type_optional&
  force_type ();

  void
  force_type (const force_type_type& x);

  void
  force_type (const force_type_optional& x);

  void
  force_type (::std::auto_ptr< force_type_type > p);

  // force_arg1
  //
  typedef ::xml_schema::double_ force_arg1_type;
  typedef ::xsd::cxx::tree::optional< force_arg1_type > force_arg1_optional;
  typedef ::xsd::cxx::tree::traits< force_arg1_type, char, ::xsd::cxx::tree::schema_type::double_ > force_arg1_traits;

  const force_arg1_optional&
  force_arg1 () const;

  force_arg1_optional&
  force_arg1 ();

  void
  force_arg1 (const force_arg1_type& x);

  void
  force_arg1 (const force_arg1_optional& x);

  // force_arg2
  //
  typedef ::xml_schema::double_ force_arg2_type;
  typedef ::xsd::cxx::tree::optional< force_arg2_type > force_arg2_optional;
  typedef ::xsd::cxx::tree::traits< force_arg2_type, char, ::xsd::cxx::tree::schema_type::double_ > force_arg2_traits;

  const force_arg2_optional&
  force_arg2 () const;

  force_arg2_optional&
  force_arg2 ();

  void
  force_arg2 (const force_arg2_type& x);

  void
  force_arg2 (const force_arg2_optional& x);

  // Constructors.
  //
  Boundary (const typeLEFT_type&,
            const typeRIGHT_type&,
            const typeTOP_type&,
            const typeBOTTOM_type&,
            const typeFRONT_type&,
            const typeBACK_type&,
            const origin_type&,
            const extent_type&,
            const grid_constant_type&);

  Boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Boundary (const Boundary& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Boundary*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Boundary&
  operator= (const Boundary& x);

  virtual 
  ~Boundary ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< typeLEFT_type > typeLEFT_;
  ::xsd::cxx::tree::one< typeRIGHT_type > typeRIGHT_;
  ::xsd::cxx::tree::one< typeTOP_type > typeTOP_;
  ::xsd::cxx::tree::one< typeBOTTOM_type > typeBOTTOM_;
  ::xsd::cxx::tree::one< typeFRONT_type > typeFRONT_;
  ::xsd::cxx::tree::one< typeBACK_type > typeBACK_;
  ::xsd::cxx::tree::one< origin_type > origin_;
  ::xsd::cxx::tree::one< extent_type > extent_;
  ::xsd::cxx::tree::one< grid_constant_type > grid_constant_;
  force_type_optional force_type_;
  force_arg1_optional force_arg1_;
  force_arg2_optional force_arg2_;
};

class simulation: public ::xml_schema::type
{
  public:
  // output
  //
  typedef ::output output_type;
  typedef ::xsd::cxx::tree::traits< output_type, char > output_traits;

  const output_type&
  output () const;

  output_type&
  output ();

  void
  output (const output_type& x);

  void
  output (::std::auto_ptr< output_type > p);

  // parameters
  //
  typedef ::parameters parameters_type;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_type&
  parameters () const;

  parameters_type&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // Boundary
  //
  typedef ::Boundary Boundary_type;
  typedef ::xsd::cxx::tree::traits< Boundary_type, char > Boundary_traits;

  const Boundary_type&
  Boundary () const;

  Boundary_type&
  Boundary ();

  void
  Boundary (const Boundary_type& x);

  void
  Boundary (::std::auto_ptr< Boundary_type > p);

  // Forces
  //
  typedef ::Forces Forces_type;
  typedef ::xsd::cxx::tree::traits< Forces_type, char > Forces_traits;

  const Forces_type&
  Forces () const;

  Forces_type&
  Forces ();

  void
  Forces (const Forces_type& x);

  void
  Forces (::std::auto_ptr< Forces_type > p);

  // ConstantForces
  //
  typedef ::ConstantForces ConstantForces_type;
  typedef ::xsd::cxx::tree::sequence< ConstantForces_type > ConstantForces_sequence;
  typedef ConstantForces_sequence::iterator ConstantForces_iterator;
  typedef ConstantForces_sequence::const_iterator ConstantForces_const_iterator;
  typedef ::xsd::cxx::tree::traits< ConstantForces_type, char > ConstantForces_traits;

  const ConstantForces_sequence&
  ConstantForces () const;

  ConstantForces_sequence&
  ConstantForces ();

  void
  ConstantForces (const ConstantForces_sequence& s);

  // Thermostat
  //
  typedef ::Thermostat Thermostat_type;
  typedef ::xsd::cxx::tree::optional< Thermostat_type > Thermostat_optional;
  typedef ::xsd::cxx::tree::traits< Thermostat_type, char > Thermostat_traits;

  const Thermostat_optional&
  Thermostat () const;

  Thermostat_optional&
  Thermostat ();

  void
  Thermostat (const Thermostat_type& x);

  void
  Thermostat (const Thermostat_optional& x);

  void
  Thermostat (::std::auto_ptr< Thermostat_type > p);

  // particles
  //
  typedef ::particles particles_type;
  typedef ::xsd::cxx::tree::sequence< particles_type > particles_sequence;
  typedef particles_sequence::iterator particles_iterator;
  typedef particles_sequence::const_iterator particles_const_iterator;
  typedef ::xsd::cxx::tree::traits< particles_type, char > particles_traits;

  const particles_sequence&
  particles () const;

  particles_sequence&
  particles ();

  void
  particles (const particles_sequence& s);

  // cuboids
  //
  typedef ::cuboids cuboids_type;
  typedef ::xsd::cxx::tree::sequence< cuboids_type > cuboids_sequence;
  typedef cuboids_sequence::iterator cuboids_iterator;
  typedef cuboids_sequence::const_iterator cuboids_const_iterator;
  typedef ::xsd::cxx::tree::traits< cuboids_type, char > cuboids_traits;

  const cuboids_sequence&
  cuboids () const;

  cuboids_sequence&
  cuboids ();

  void
  cuboids (const cuboids_sequence& s);

  // spheres
  //
  typedef ::spheres spheres_type;
  typedef ::xsd::cxx::tree::sequence< spheres_type > spheres_sequence;
  typedef spheres_sequence::iterator spheres_iterator;
  typedef spheres_sequence::const_iterator spheres_const_iterator;
  typedef ::xsd::cxx::tree::traits< spheres_type, char > spheres_traits;

  const spheres_sequence&
  spheres () const;

  spheres_sequence&
  spheres ();

  void
  spheres (const spheres_sequence& s);

  // membranes
  //
  typedef ::membranes membranes_type;
  typedef ::xsd::cxx::tree::sequence< membranes_type > membranes_sequence;
  typedef membranes_sequence::iterator membranes_iterator;
  typedef membranes_sequence::const_iterator membranes_const_iterator;
  typedef ::xsd::cxx::tree::traits< membranes_type, char > membranes_traits;

  const membranes_sequence&
  membranes () const;

  membranes_sequence&
  membranes ();

  void
  membranes (const membranes_sequence& s);

  // statistics
  //
  typedef ::statistics statistics_type;
  typedef ::xsd::cxx::tree::optional< statistics_type > statistics_optional;
  typedef ::xsd::cxx::tree::traits< statistics_type, char > statistics_traits;

  const statistics_optional&
  statistics () const;

  statistics_optional&
  statistics ();

  void
  statistics (const statistics_type& x);

  void
  statistics (const statistics_optional& x);

  void
  statistics (::std::auto_ptr< statistics_type > p);

  // Constructors.
  //
  simulation (const output_type&,
              const parameters_type&,
              const Boundary_type&,
              const Forces_type&);

  simulation (::std::auto_ptr< output_type >,
              ::std::auto_ptr< parameters_type >,
              ::std::auto_ptr< Boundary_type >,
              ::std::auto_ptr< Forces_type >);

  simulation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  simulation (const simulation& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual simulation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  simulation&
  operator= (const simulation& x);

  virtual 
  ~simulation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< output_type > output_;
  ::xsd::cxx::tree::one< parameters_type > parameters_;
  ::xsd::cxx::tree::one< Boundary_type > Boundary_;
  ::xsd::cxx::tree::one< Forces_type > Forces_;
  ConstantForces_sequence ConstantForces_;
  Thermostat_optional Thermostat_;
  particles_sequence particles_;
  cuboids_sequence cuboids_;
  spheres_sequence spheres_;
  membranes_sequence membranes_;
  statistics_optional statistics_;
};

class output: public ::xml_schema::type
{
  public:
  // base_name
  //
  typedef ::xml_schema::string base_name_type;
  typedef ::xsd::cxx::tree::traits< base_name_type, char > base_name_traits;

  const base_name_type&
  base_name () const;

  base_name_type&
  base_name ();

  void
  base_name (const base_name_type& x);

  void
  base_name (::std::auto_ptr< base_name_type > p);

  // write_frequency
  //
  typedef ::xml_schema::int_ write_frequency_type;
  typedef ::xsd::cxx::tree::traits< write_frequency_type, char > write_frequency_traits;

  const write_frequency_type&
  write_frequency () const;

  write_frequency_type&
  write_frequency ();

  void
  write_frequency (const write_frequency_type& x);

  // Constructors.
  //
  output (const base_name_type&,
          const write_frequency_type&);

  output (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  output (const output& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual output*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  output&
  operator= (const output& x);

  virtual 
  ~output ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< base_name_type > base_name_;
  ::xsd::cxx::tree::one< write_frequency_type > write_frequency_;
};

class parameters: public ::xml_schema::type
{
  public:
  // end_t
  //
  typedef ::xml_schema::double_ end_t_type;
  typedef ::xsd::cxx::tree::traits< end_t_type, char, ::xsd::cxx::tree::schema_type::double_ > end_t_traits;

  const end_t_type&
  end_t () const;

  end_t_type&
  end_t ();

  void
  end_t (const end_t_type& x);

  // delta_t
  //
  typedef ::xml_schema::double_ delta_t_type;
  typedef ::xsd::cxx::tree::traits< delta_t_type, char, ::xsd::cxx::tree::schema_type::double_ > delta_t_traits;

  const delta_t_type&
  delta_t () const;

  delta_t_type&
  delta_t ();

  void
  delta_t (const delta_t_type& x);

  // cutoff_radius
  //
  typedef ::xml_schema::double_ cutoff_radius_type;
  typedef ::xsd::cxx::tree::traits< cutoff_radius_type, char, ::xsd::cxx::tree::schema_type::double_ > cutoff_radius_traits;

  const cutoff_radius_type&
  cutoff_radius () const;

  cutoff_radius_type&
  cutoff_radius ();

  void
  cutoff_radius (const cutoff_radius_type& x);

  // parallel_strategy
  //
  typedef ::ParallelType parallel_strategy_type;
  typedef ::xsd::cxx::tree::traits< parallel_strategy_type, char > parallel_strategy_traits;

  const parallel_strategy_type&
  parallel_strategy () const;

  parallel_strategy_type&
  parallel_strategy ();

  void
  parallel_strategy (const parallel_strategy_type& x);

  void
  parallel_strategy (::std::auto_ptr< parallel_strategy_type > p);

  // Constructors.
  //
  parameters (const end_t_type&,
              const delta_t_type&,
              const cutoff_radius_type&,
              const parallel_strategy_type&);

  parameters (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  parameters (const parameters& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual parameters*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  parameters&
  operator= (const parameters& x);

  virtual 
  ~parameters ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< end_t_type > end_t_;
  ::xsd::cxx::tree::one< delta_t_type > delta_t_;
  ::xsd::cxx::tree::one< cutoff_radius_type > cutoff_radius_;
  ::xsd::cxx::tree::one< parallel_strategy_type > parallel_strategy_;
};

class Forces: public ::xml_schema::type
{
  public:
  // Force
  //
  typedef ::Force Force_type;
  typedef ::xsd::cxx::tree::sequence< Force_type > Force_sequence;
  typedef Force_sequence::iterator Force_iterator;
  typedef Force_sequence::const_iterator Force_const_iterator;
  typedef ::xsd::cxx::tree::traits< Force_type, char > Force_traits;

  const Force_sequence&
  Force () const;

  Force_sequence&
  Force ();

  void
  Force (const Force_sequence& s);

  // Constructors.
  //
  Forces ();

  Forces (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  Forces (const Forces& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual Forces*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Forces&
  operator= (const Forces& x);

  virtual 
  ~Forces ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Force_sequence Force_;
};

class ConstantForces: public ::xml_schema::type
{
  public:
  // ConstantForce
  //
  typedef ::ConstantForce ConstantForce_type;
  typedef ::xsd::cxx::tree::traits< ConstantForce_type, char > ConstantForce_traits;

  const ConstantForce_type&
  ConstantForce () const;

  ConstantForce_type&
  ConstantForce ();

  void
  ConstantForce (const ConstantForce_type& x);

  void
  ConstantForce (::std::auto_ptr< ConstantForce_type > p);

  // Constructors.
  //
  ConstantForces (const ConstantForce_type&);

  ConstantForces (::std::auto_ptr< ConstantForce_type >);

  ConstantForces (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  ConstantForces (const ConstantForces& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual ConstantForces*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ConstantForces&
  operator= (const ConstantForces& x);

  virtual 
  ~ConstantForces ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ConstantForce_type > ConstantForce_;
};

class Thermostat: public ::xml_schema::type
{
  public:
  // n_thermostats
  //
  typedef ::xml_schema::int_ n_thermostats_type;
  typedef ::xsd::cxx::tree::traits< n_thermostats_type, char > n_thermostats_traits;

  const n_thermostats_type&
  n_thermostats () const;

  n_thermostats_type&
  n_thermostats ();

  void
  n_thermostats (const n_thermostats_type& x);

  // init_T
  //
  typedef ::xml_schema::double_ init_T_type;
  typedef ::xsd::cxx::tree::traits< init_T_type, char, ::xsd::cxx::tree::schema_type::double_ > init_T_traits;

  const init_T_type&
  init_T () const;

  init_T_type&
  init_T ();

  void
  init_T (const init_T_type& x);

  // target_T
  //
  typedef ::xml_schema::double_ target_T_type;
  typedef ::xsd::cxx::tree::optional< target_T_type > target_T_optional;
  typedef ::xsd::cxx::tree::traits< target_T_type, char, ::xsd::cxx::tree::schema_type::double_ > target_T_traits;

  const target_T_optional&
  target_T () const;

  target_T_optional&
  target_T ();

  void
  target_T (const target_T_type& x);

  void
  target_T (const target_T_optional& x);

  static target_T_type
  target_T_default_value ();

  // temp_dT
  //
  typedef ::xml_schema::double_ temp_dT_type;
  typedef ::xsd::cxx::tree::optional< temp_dT_type > temp_dT_optional;
  typedef ::xsd::cxx::tree::traits< temp_dT_type, char, ::xsd::cxx::tree::schema_type::double_ > temp_dT_traits;

  const temp_dT_optional&
  temp_dT () const;

  temp_dT_optional&
  temp_dT ();

  void
  temp_dT (const temp_dT_type& x);

  void
  temp_dT (const temp_dT_optional& x);

  static temp_dT_type
  temp_dT_default_value ();

  // Constructors.
  //
  Thermostat (const n_thermostats_type&,
              const init_T_type&);

  Thermostat (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  Thermostat (const Thermostat& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual Thermostat*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Thermostat&
  operator= (const Thermostat& x);

  virtual 
  ~Thermostat ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< n_thermostats_type > n_thermostats_;
  ::xsd::cxx::tree::one< init_T_type > init_T_;
  target_T_optional target_T_;
  temp_dT_optional temp_dT_;
};

class particles: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::Vec3Type origin_type;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_type&
  origin () const;

  origin_type&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // velocity
  //
  typedef ::Vec3Type velocity_type;
  typedef ::xsd::cxx::tree::traits< velocity_type, char > velocity_traits;

  const velocity_type&
  velocity () const;

  velocity_type&
  velocity ();

  void
  velocity (const velocity_type& x);

  void
  velocity (::std::auto_ptr< velocity_type > p);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // type
  //
  typedef ::xml_schema::int_ type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  // state
  //
  typedef ::ParticleStateType state_type;
  typedef ::xsd::cxx::tree::traits< state_type, char > state_traits;

  const state_type&
  state () const;

  state_type&
  state ();

  void
  state (const state_type& x);

  void
  state (::std::auto_ptr< state_type > p);

  static const state_type&
  state_default_value ();

  // Constructors.
  //
  particles (const origin_type&,
             const velocity_type&,
             const mass_type&,
             const type_type&,
             const state_type&);

  particles (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  particles (const particles& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual particles*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  particles&
  operator= (const particles& x);

  virtual 
  ~particles ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< origin_type > origin_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< state_type > state_;
  static const state_type state_default_value_;
};

class cuboids: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::Vec3Type origin_type;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_type&
  origin () const;

  origin_type&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // velocity
  //
  typedef ::Vec3Type velocity_type;
  typedef ::xsd::cxx::tree::traits< velocity_type, char > velocity_traits;

  const velocity_type&
  velocity () const;

  velocity_type&
  velocity ();

  void
  velocity (const velocity_type& x);

  void
  velocity (::std::auto_ptr< velocity_type > p);

  // numPart
  //
  typedef ::Int3Type numPart_type;
  typedef ::xsd::cxx::tree::traits< numPart_type, char > numPart_traits;

  const numPart_type&
  numPart () const;

  numPart_type&
  numPart ();

  void
  numPart (const numPart_type& x);

  void
  numPart (::std::auto_ptr< numPart_type > p);

  // thermal_v
  //
  typedef ::xml_schema::double_ thermal_v_type;
  typedef ::xsd::cxx::tree::traits< thermal_v_type, char, ::xsd::cxx::tree::schema_type::double_ > thermal_v_traits;

  const thermal_v_type&
  thermal_v () const;

  thermal_v_type&
  thermal_v ();

  void
  thermal_v (const thermal_v_type& x);

  static thermal_v_type
  thermal_v_default_value ();

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // dimension
  //
  typedef ::DimensionType dimension_type;
  typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

  const dimension_type&
  dimension () const;

  dimension_type&
  dimension ();

  void
  dimension (const dimension_type& x);

  void
  dimension (::std::auto_ptr< dimension_type > p);

  // type
  //
  typedef ::xml_schema::int_ type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  static type_type
  type_default_value ();

  // state
  //
  typedef ::ParticleStateType state_type;
  typedef ::xsd::cxx::tree::traits< state_type, char > state_traits;

  const state_type&
  state () const;

  state_type&
  state ();

  void
  state (const state_type& x);

  void
  state (::std::auto_ptr< state_type > p);

  static const state_type&
  state_default_value ();

  // Constructors.
  //
  cuboids (const origin_type&,
           const velocity_type&,
           const numPart_type&,
           const thermal_v_type&,
           const width_type&,
           const mass_type&,
           const dimension_type&,
           const type_type&,
           const state_type&);

  cuboids (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  cuboids (const cuboids& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual cuboids*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  cuboids&
  operator= (const cuboids& x);

  virtual 
  ~cuboids ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< origin_type > origin_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
  ::xsd::cxx::tree::one< numPart_type > numPart_;
  ::xsd::cxx::tree::one< thermal_v_type > thermal_v_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< dimension_type > dimension_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< state_type > state_;
  static const state_type state_default_value_;
};

class spheres: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::Vec3Type origin_type;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_type&
  origin () const;

  origin_type&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // velocity
  //
  typedef ::Vec3Type velocity_type;
  typedef ::xsd::cxx::tree::traits< velocity_type, char > velocity_traits;

  const velocity_type&
  velocity () const;

  velocity_type&
  velocity ();

  void
  velocity (const velocity_type& x);

  void
  velocity (::std::auto_ptr< velocity_type > p);

  // thermal_v
  //
  typedef ::xml_schema::double_ thermal_v_type;
  typedef ::xsd::cxx::tree::traits< thermal_v_type, char, ::xsd::cxx::tree::schema_type::double_ > thermal_v_traits;

  const thermal_v_type&
  thermal_v () const;

  thermal_v_type&
  thermal_v ();

  void
  thermal_v (const thermal_v_type& x);

  static thermal_v_type
  thermal_v_default_value ();

  // radius
  //
  typedef ::xml_schema::int_ radius_type;
  typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

  const radius_type&
  radius () const;

  radius_type&
  radius ();

  void
  radius (const radius_type& x);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // dimension
  //
  typedef ::DimensionType dimension_type;
  typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

  const dimension_type&
  dimension () const;

  dimension_type&
  dimension ();

  void
  dimension (const dimension_type& x);

  void
  dimension (::std::auto_ptr< dimension_type > p);

  // type
  //
  typedef ::xml_schema::int_ type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  static type_type
  type_default_value ();

  // state
  //
  typedef ::ParticleStateType state_type;
  typedef ::xsd::cxx::tree::traits< state_type, char > state_traits;

  const state_type&
  state () const;

  state_type&
  state ();

  void
  state (const state_type& x);

  void
  state (::std::auto_ptr< state_type > p);

  static const state_type&
  state_default_value ();

  // Constructors.
  //
  spheres (const origin_type&,
           const velocity_type&,
           const thermal_v_type&,
           const radius_type&,
           const width_type&,
           const mass_type&,
           const dimension_type&,
           const type_type&,
           const state_type&);

  spheres (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  spheres (const spheres& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual spheres*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  spheres&
  operator= (const spheres& x);

  virtual 
  ~spheres ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< origin_type > origin_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
  ::xsd::cxx::tree::one< thermal_v_type > thermal_v_;
  ::xsd::cxx::tree::one< radius_type > radius_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< dimension_type > dimension_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< state_type > state_;
  static const state_type state_default_value_;
};

class membranes: public ::xml_schema::type
{
  public:
  // origin
  //
  typedef ::Vec3Type origin_type;
  typedef ::xsd::cxx::tree::traits< origin_type, char > origin_traits;

  const origin_type&
  origin () const;

  origin_type&
  origin ();

  void
  origin (const origin_type& x);

  void
  origin (::std::auto_ptr< origin_type > p);

  // velocity
  //
  typedef ::Vec3Type velocity_type;
  typedef ::xsd::cxx::tree::traits< velocity_type, char > velocity_traits;

  const velocity_type&
  velocity () const;

  velocity_type&
  velocity ();

  void
  velocity (const velocity_type& x);

  void
  velocity (::std::auto_ptr< velocity_type > p);

  // numPart
  //
  typedef ::Int3Type numPart_type;
  typedef ::xsd::cxx::tree::traits< numPart_type, char > numPart_traits;

  const numPart_type&
  numPart () const;

  numPart_type&
  numPart ();

  void
  numPart (const numPart_type& x);

  void
  numPart (::std::auto_ptr< numPart_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // k
  //
  typedef ::xml_schema::double_ k_type;
  typedef ::xsd::cxx::tree::traits< k_type, char, ::xsd::cxx::tree::schema_type::double_ > k_traits;

  const k_type&
  k () const;

  k_type&
  k ();

  void
  k (const k_type& x);

  // cutoff
  //
  typedef ::xml_schema::double_ cutoff_type;
  typedef ::xsd::cxx::tree::traits< cutoff_type, char, ::xsd::cxx::tree::schema_type::double_ > cutoff_traits;

  const cutoff_type&
  cutoff () const;

  cutoff_type&
  cutoff ();

  void
  cutoff (const cutoff_type& x);

  // type
  //
  typedef ::xml_schema::int_ type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  static type_type
  type_default_value ();

  // Constructors.
  //
  membranes (const origin_type&,
             const velocity_type&,
             const numPart_type&,
             const width_type&,
             const mass_type&,
             const k_type&,
             const cutoff_type&,
             const type_type&);

  membranes (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  membranes (const membranes& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual membranes*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  membranes&
  operator= (const membranes& x);

  virtual 
  ~membranes ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< origin_type > origin_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
  ::xsd::cxx::tree::one< numPart_type > numPart_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< k_type > k_;
  ::xsd::cxx::tree::one< cutoff_type > cutoff_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class statistics: public ::xml_schema::type
{
  public:
  // compute_freq
  //
  typedef ::xml_schema::int_ compute_freq_type;
  typedef ::xsd::cxx::tree::traits< compute_freq_type, char > compute_freq_traits;

  const compute_freq_type&
  compute_freq () const;

  compute_freq_type&
  compute_freq ();

  void
  compute_freq (const compute_freq_type& x);

  // n_bins
  //
  typedef ::xml_schema::int_ n_bins_type;
  typedef ::xsd::cxx::tree::traits< n_bins_type, char > n_bins_traits;

  const n_bins_type&
  n_bins () const;

  n_bins_type&
  n_bins ();

  void
  n_bins (const n_bins_type& x);

  // Constructors.
  //
  statistics (const compute_freq_type&,
              const n_bins_type&);

  statistics (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  statistics (const statistics& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual statistics*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  statistics&
  operator= (const statistics& x);

  virtual 
  ~statistics ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< compute_freq_type > compute_freq_;
  ::xsd::cxx::tree::one< n_bins_type > n_bins_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const Vec3Type_base&);

void
operator<< (::xercesc::DOMAttr&, const Vec3Type_base&);

void
operator<< (::xml_schema::list_stream&,
            const Vec3Type_base&);

void
operator<< (::xercesc::DOMElement&, const Vec3Type&);

void
operator<< (::xercesc::DOMAttr&, const Vec3Type&);

void
operator<< (::xml_schema::list_stream&,
            const Vec3Type&);

void
operator<< (::xercesc::DOMElement&, const Int3Type_base&);

void
operator<< (::xercesc::DOMAttr&, const Int3Type_base&);

void
operator<< (::xml_schema::list_stream&,
            const Int3Type_base&);

void
operator<< (::xercesc::DOMElement&, const Int3Type&);

void
operator<< (::xercesc::DOMAttr&, const Int3Type&);

void
operator<< (::xml_schema::list_stream&,
            const Int3Type&);

void
operator<< (::xercesc::DOMElement&, const DimensionType&);

void
operator<< (::xercesc::DOMAttr&, const DimensionType&);

void
operator<< (::xml_schema::list_stream&,
            const DimensionType&);

void
operator<< (::xercesc::DOMElement&, const ForceType&);

void
operator<< (::xercesc::DOMAttr&, const ForceType&);

void
operator<< (::xml_schema::list_stream&,
            const ForceType&);

void
operator<< (::xercesc::DOMElement&, const ConstantForceType&);

void
operator<< (::xercesc::DOMAttr&, const ConstantForceType&);

void
operator<< (::xml_schema::list_stream&,
            const ConstantForceType&);

void
operator<< (::xercesc::DOMElement&, const BoundaryType&);

void
operator<< (::xercesc::DOMAttr&, const BoundaryType&);

void
operator<< (::xml_schema::list_stream&,
            const BoundaryType&);

void
operator<< (::xercesc::DOMElement&, const ParticleStateType&);

void
operator<< (::xercesc::DOMAttr&, const ParticleStateType&);

void
operator<< (::xml_schema::list_stream&,
            const ParticleStateType&);

void
operator<< (::xercesc::DOMElement&, const ParallelType&);

void
operator<< (::xercesc::DOMAttr&, const ParallelType&);

void
operator<< (::xml_schema::list_stream&,
            const ParallelType&);

void
operator<< (::xercesc::DOMElement&, const Force&);

void
operator<< (::xercesc::DOMElement&, const ConstantForce&);

void
operator<< (::xercesc::DOMElement&, const Boundary&);

// Serialize to std::ostream.
//

void
simulation_ (::std::ostream& os,
             const ::simulation& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::std::ostream& os,
             const ::simulation& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::std::ostream& os,
             const ::simulation& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
simulation_ (::xercesc::XMLFormatTarget& ft,
             const ::simulation& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::xercesc::XMLFormatTarget& ft,
             const ::simulation& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::xercesc::XMLFormatTarget& ft,
             const ::simulation& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
simulation_ (::xercesc::DOMDocument& d,
             const ::simulation& x,
             ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
simulation_ (const ::simulation& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const simulation&);

void
operator<< (::xercesc::DOMElement&, const output&);

void
operator<< (::xercesc::DOMElement&, const parameters&);

void
operator<< (::xercesc::DOMElement&, const Forces&);

void
operator<< (::xercesc::DOMElement&, const ConstantForces&);

void
operator<< (::xercesc::DOMElement&, const Thermostat&);

void
operator<< (::xercesc::DOMElement&, const particles&);

void
operator<< (::xercesc::DOMElement&, const cuboids&);

void
operator<< (::xercesc::DOMElement&, const spheres&);

void
operator<< (::xercesc::DOMElement&, const membranes&);

void
operator<< (::xercesc::DOMElement&, const statistics&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MOL_SIM_SCHEMA_HXX
