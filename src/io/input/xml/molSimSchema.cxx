// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "molSimSchema.hxx"

// Vec3Type_base
//

Vec3Type_base::
Vec3Type_base ()
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
{
}

Vec3Type_base::
Vec3Type_base (size_type n, const ::xml_schema::double_& x)
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
{
}

Vec3Type_base::
Vec3Type_base (const Vec3Type_base& o,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
{
}

// Vec3Type
// 


// Int3Type_base
//

Int3Type_base::
Int3Type_base ()
: ::xsd::cxx::tree::list< ::xml_schema::int_, char > (this)
{
}

Int3Type_base::
Int3Type_base (size_type n, const ::xml_schema::int_& x)
: ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
{
}

Int3Type_base::
Int3Type_base (const Int3Type_base& o,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
{
}

// Int3Type
// 


// DimensionType
// 

DimensionType::
DimensionType (::xml_schema::int_ v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v)
{
}

DimensionType::
DimensionType (const DimensionType& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v, f, c)
{
}


// ForceType
// 

ForceType::
ForceType (value v)
: ::xml_schema::string (_xsd_ForceType_literals_[v])
{
}

ForceType::
ForceType (const char* v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ForceType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ForceType& ForceType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ForceType_literals_[v]);

  return *this;
}


// ConstantForceType
// 

ConstantForceType::
ConstantForceType (value v)
: ::xml_schema::string (_xsd_ConstantForceType_literals_[v])
{
}

ConstantForceType::
ConstantForceType (const char* v)
: ::xml_schema::string (v)
{
}

ConstantForceType::
ConstantForceType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ConstantForceType::
ConstantForceType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ConstantForceType::
ConstantForceType (const ConstantForceType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ConstantForceType& ConstantForceType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ConstantForceType_literals_[v]);

  return *this;
}


// BoundaryType
// 

BoundaryType::
BoundaryType (value v)
: ::xml_schema::string (_xsd_BoundaryType_literals_[v])
{
}

BoundaryType::
BoundaryType (const char* v)
: ::xml_schema::string (v)
{
}

BoundaryType::
BoundaryType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

BoundaryType::
BoundaryType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

BoundaryType::
BoundaryType (const BoundaryType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

BoundaryType& BoundaryType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_BoundaryType_literals_[v]);

  return *this;
}


// ParticleStateType
// 

ParticleStateType::
ParticleStateType (value v)
: ::xml_schema::string (_xsd_ParticleStateType_literals_[v])
{
}

ParticleStateType::
ParticleStateType (const char* v)
: ::xml_schema::string (v)
{
}

ParticleStateType::
ParticleStateType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ParticleStateType::
ParticleStateType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ParticleStateType::
ParticleStateType (const ParticleStateType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ParticleStateType& ParticleStateType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ParticleStateType_literals_[v]);

  return *this;
}


// ParallelType
// 

ParallelType::
ParallelType (value v)
: ::xml_schema::string (_xsd_ParallelType_literals_[v])
{
}

ParallelType::
ParallelType (const char* v)
: ::xml_schema::string (v)
{
}

ParallelType::
ParallelType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ParallelType::
ParallelType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ParallelType::
ParallelType (const ParallelType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ParallelType& ParallelType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ParallelType_literals_[v]);

  return *this;
}


// Force
// 

const Force::type_type& Force::
type () const
{
  return this->type_.get ();
}

Force::type_type& Force::
type ()
{
  return this->type_.get ();
}

void Force::
type (const type_type& x)
{
  this->type_.set (x);
}

void Force::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const Force::partType_type& Force::
partType () const
{
  return this->partType_.get ();
}

Force::partType_type& Force::
partType ()
{
  return this->partType_.get ();
}

void Force::
partType (const partType_type& x)
{
  this->partType_.set (x);
}

const Force::arg1_optional& Force::
arg1 () const
{
  return this->arg1_;
}

Force::arg1_optional& Force::
arg1 ()
{
  return this->arg1_;
}

void Force::
arg1 (const arg1_type& x)
{
  this->arg1_.set (x);
}

void Force::
arg1 (const arg1_optional& x)
{
  this->arg1_ = x;
}

const Force::arg2_optional& Force::
arg2 () const
{
  return this->arg2_;
}

Force::arg2_optional& Force::
arg2 ()
{
  return this->arg2_;
}

void Force::
arg2 (const arg2_type& x)
{
  this->arg2_.set (x);
}

void Force::
arg2 (const arg2_optional& x)
{
  this->arg2_ = x;
}


// ConstantForce
// 

const ConstantForce::type_type& ConstantForce::
type () const
{
  return this->type_.get ();
}

ConstantForce::type_type& ConstantForce::
type ()
{
  return this->type_.get ();
}

void ConstantForce::
type (const type_type& x)
{
  this->type_.set (x);
}

void ConstantForce::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const ConstantForce::direction_type& ConstantForce::
direction () const
{
  return this->direction_.get ();
}

ConstantForce::direction_type& ConstantForce::
direction ()
{
  return this->direction_.get ();
}

void ConstantForce::
direction (const direction_type& x)
{
  this->direction_.set (x);
}

void ConstantForce::
direction (::std::auto_ptr< direction_type > x)
{
  this->direction_.set (x);
}

const ConstantForce::strength_type& ConstantForce::
strength () const
{
  return this->strength_.get ();
}

ConstantForce::strength_type& ConstantForce::
strength ()
{
  return this->strength_.get ();
}

void ConstantForce::
strength (const strength_type& x)
{
  this->strength_.set (x);
}

const ConstantForce::MarkBoxVec1_optional& ConstantForce::
MarkBoxVec1 () const
{
  return this->MarkBoxVec1_;
}

ConstantForce::MarkBoxVec1_optional& ConstantForce::
MarkBoxVec1 ()
{
  return this->MarkBoxVec1_;
}

void ConstantForce::
MarkBoxVec1 (const MarkBoxVec1_type& x)
{
  this->MarkBoxVec1_.set (x);
}

void ConstantForce::
MarkBoxVec1 (const MarkBoxVec1_optional& x)
{
  this->MarkBoxVec1_ = x;
}

void ConstantForce::
MarkBoxVec1 (::std::auto_ptr< MarkBoxVec1_type > x)
{
  this->MarkBoxVec1_.set (x);
}

const ConstantForce::MarkBoxVec2_optional& ConstantForce::
MarkBoxVec2 () const
{
  return this->MarkBoxVec2_;
}

ConstantForce::MarkBoxVec2_optional& ConstantForce::
MarkBoxVec2 ()
{
  return this->MarkBoxVec2_;
}

void ConstantForce::
MarkBoxVec2 (const MarkBoxVec2_type& x)
{
  this->MarkBoxVec2_.set (x);
}

void ConstantForce::
MarkBoxVec2 (const MarkBoxVec2_optional& x)
{
  this->MarkBoxVec2_ = x;
}

void ConstantForce::
MarkBoxVec2 (::std::auto_ptr< MarkBoxVec2_type > x)
{
  this->MarkBoxVec2_.set (x);
}

const ConstantForce::start_t_type& ConstantForce::
start_t () const
{
  return this->start_t_.get ();
}

ConstantForce::start_t_type& ConstantForce::
start_t ()
{
  return this->start_t_.get ();
}

void ConstantForce::
start_t (const start_t_type& x)
{
  this->start_t_.set (x);
}

ConstantForce::start_t_type ConstantForce::
start_t_default_value ()
{
  return start_t_type (0.0);
}

const ConstantForce::end_t_type& ConstantForce::
end_t () const
{
  return this->end_t_.get ();
}

ConstantForce::end_t_type& ConstantForce::
end_t ()
{
  return this->end_t_.get ();
}

void ConstantForce::
end_t (const end_t_type& x)
{
  this->end_t_.set (x);
}

ConstantForce::end_t_type ConstantForce::
end_t_default_value ()
{
  return end_t_type (0.0);
}

const ConstantForce::const_acc_type& ConstantForce::
const_acc () const
{
  return this->const_acc_.get ();
}

ConstantForce::const_acc_type& ConstantForce::
const_acc ()
{
  return this->const_acc_.get ();
}

void ConstantForce::
const_acc (const const_acc_type& x)
{
  this->const_acc_.set (x);
}

ConstantForce::const_acc_type ConstantForce::
const_acc_default_value ()
{
  return const_acc_type (false);
}


// Boundary
// 

const Boundary::typeLEFT_type& Boundary::
typeLEFT () const
{
  return this->typeLEFT_.get ();
}

Boundary::typeLEFT_type& Boundary::
typeLEFT ()
{
  return this->typeLEFT_.get ();
}

void Boundary::
typeLEFT (const typeLEFT_type& x)
{
  this->typeLEFT_.set (x);
}

void Boundary::
typeLEFT (::std::auto_ptr< typeLEFT_type > x)
{
  this->typeLEFT_.set (x);
}

const Boundary::typeRIGHT_type& Boundary::
typeRIGHT () const
{
  return this->typeRIGHT_.get ();
}

Boundary::typeRIGHT_type& Boundary::
typeRIGHT ()
{
  return this->typeRIGHT_.get ();
}

void Boundary::
typeRIGHT (const typeRIGHT_type& x)
{
  this->typeRIGHT_.set (x);
}

void Boundary::
typeRIGHT (::std::auto_ptr< typeRIGHT_type > x)
{
  this->typeRIGHT_.set (x);
}

const Boundary::typeTOP_type& Boundary::
typeTOP () const
{
  return this->typeTOP_.get ();
}

Boundary::typeTOP_type& Boundary::
typeTOP ()
{
  return this->typeTOP_.get ();
}

void Boundary::
typeTOP (const typeTOP_type& x)
{
  this->typeTOP_.set (x);
}

void Boundary::
typeTOP (::std::auto_ptr< typeTOP_type > x)
{
  this->typeTOP_.set (x);
}

const Boundary::typeBOTTOM_type& Boundary::
typeBOTTOM () const
{
  return this->typeBOTTOM_.get ();
}

Boundary::typeBOTTOM_type& Boundary::
typeBOTTOM ()
{
  return this->typeBOTTOM_.get ();
}

void Boundary::
typeBOTTOM (const typeBOTTOM_type& x)
{
  this->typeBOTTOM_.set (x);
}

void Boundary::
typeBOTTOM (::std::auto_ptr< typeBOTTOM_type > x)
{
  this->typeBOTTOM_.set (x);
}

const Boundary::typeFRONT_type& Boundary::
typeFRONT () const
{
  return this->typeFRONT_.get ();
}

Boundary::typeFRONT_type& Boundary::
typeFRONT ()
{
  return this->typeFRONT_.get ();
}

void Boundary::
typeFRONT (const typeFRONT_type& x)
{
  this->typeFRONT_.set (x);
}

void Boundary::
typeFRONT (::std::auto_ptr< typeFRONT_type > x)
{
  this->typeFRONT_.set (x);
}

const Boundary::typeBACK_type& Boundary::
typeBACK () const
{
  return this->typeBACK_.get ();
}

Boundary::typeBACK_type& Boundary::
typeBACK ()
{
  return this->typeBACK_.get ();
}

void Boundary::
typeBACK (const typeBACK_type& x)
{
  this->typeBACK_.set (x);
}

void Boundary::
typeBACK (::std::auto_ptr< typeBACK_type > x)
{
  this->typeBACK_.set (x);
}

const Boundary::origin_type& Boundary::
origin () const
{
  return this->origin_.get ();
}

Boundary::origin_type& Boundary::
origin ()
{
  return this->origin_.get ();
}

void Boundary::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void Boundary::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const Boundary::extent_type& Boundary::
extent () const
{
  return this->extent_.get ();
}

Boundary::extent_type& Boundary::
extent ()
{
  return this->extent_.get ();
}

void Boundary::
extent (const extent_type& x)
{
  this->extent_.set (x);
}

void Boundary::
extent (::std::auto_ptr< extent_type > x)
{
  this->extent_.set (x);
}

const Boundary::grid_constant_type& Boundary::
grid_constant () const
{
  return this->grid_constant_.get ();
}

Boundary::grid_constant_type& Boundary::
grid_constant ()
{
  return this->grid_constant_.get ();
}

void Boundary::
grid_constant (const grid_constant_type& x)
{
  this->grid_constant_.set (x);
}

const Boundary::force_type_optional& Boundary::
force_type () const
{
  return this->force_type_;
}

Boundary::force_type_optional& Boundary::
force_type ()
{
  return this->force_type_;
}

void Boundary::
force_type (const force_type_type& x)
{
  this->force_type_.set (x);
}

void Boundary::
force_type (const force_type_optional& x)
{
  this->force_type_ = x;
}

void Boundary::
force_type (::std::auto_ptr< force_type_type > x)
{
  this->force_type_.set (x);
}

const Boundary::force_arg1_optional& Boundary::
force_arg1 () const
{
  return this->force_arg1_;
}

Boundary::force_arg1_optional& Boundary::
force_arg1 ()
{
  return this->force_arg1_;
}

void Boundary::
force_arg1 (const force_arg1_type& x)
{
  this->force_arg1_.set (x);
}

void Boundary::
force_arg1 (const force_arg1_optional& x)
{
  this->force_arg1_ = x;
}

const Boundary::force_arg2_optional& Boundary::
force_arg2 () const
{
  return this->force_arg2_;
}

Boundary::force_arg2_optional& Boundary::
force_arg2 ()
{
  return this->force_arg2_;
}

void Boundary::
force_arg2 (const force_arg2_type& x)
{
  this->force_arg2_.set (x);
}

void Boundary::
force_arg2 (const force_arg2_optional& x)
{
  this->force_arg2_ = x;
}


// simulation
// 

const simulation::output_type& simulation::
output () const
{
  return this->output_.get ();
}

simulation::output_type& simulation::
output ()
{
  return this->output_.get ();
}

void simulation::
output (const output_type& x)
{
  this->output_.set (x);
}

void simulation::
output (::std::auto_ptr< output_type > x)
{
  this->output_.set (x);
}

const simulation::parameters_type& simulation::
parameters () const
{
  return this->parameters_.get ();
}

simulation::parameters_type& simulation::
parameters ()
{
  return this->parameters_.get ();
}

void simulation::
parameters (const parameters_type& x)
{
  this->parameters_.set (x);
}

void simulation::
parameters (::std::auto_ptr< parameters_type > x)
{
  this->parameters_.set (x);
}

const simulation::Boundary_type& simulation::
Boundary () const
{
  return this->Boundary_.get ();
}

simulation::Boundary_type& simulation::
Boundary ()
{
  return this->Boundary_.get ();
}

void simulation::
Boundary (const Boundary_type& x)
{
  this->Boundary_.set (x);
}

void simulation::
Boundary (::std::auto_ptr< Boundary_type > x)
{
  this->Boundary_.set (x);
}

const simulation::Forces_type& simulation::
Forces () const
{
  return this->Forces_.get ();
}

simulation::Forces_type& simulation::
Forces ()
{
  return this->Forces_.get ();
}

void simulation::
Forces (const Forces_type& x)
{
  this->Forces_.set (x);
}

void simulation::
Forces (::std::auto_ptr< Forces_type > x)
{
  this->Forces_.set (x);
}

const simulation::ConstantForces_sequence& simulation::
ConstantForces () const
{
  return this->ConstantForces_;
}

simulation::ConstantForces_sequence& simulation::
ConstantForces ()
{
  return this->ConstantForces_;
}

void simulation::
ConstantForces (const ConstantForces_sequence& s)
{
  this->ConstantForces_ = s;
}

const simulation::Thermostat_optional& simulation::
Thermostat () const
{
  return this->Thermostat_;
}

simulation::Thermostat_optional& simulation::
Thermostat ()
{
  return this->Thermostat_;
}

void simulation::
Thermostat (const Thermostat_type& x)
{
  this->Thermostat_.set (x);
}

void simulation::
Thermostat (const Thermostat_optional& x)
{
  this->Thermostat_ = x;
}

void simulation::
Thermostat (::std::auto_ptr< Thermostat_type > x)
{
  this->Thermostat_.set (x);
}

const simulation::particles_sequence& simulation::
particles () const
{
  return this->particles_;
}

simulation::particles_sequence& simulation::
particles ()
{
  return this->particles_;
}

void simulation::
particles (const particles_sequence& s)
{
  this->particles_ = s;
}

const simulation::cuboids_sequence& simulation::
cuboids () const
{
  return this->cuboids_;
}

simulation::cuboids_sequence& simulation::
cuboids ()
{
  return this->cuboids_;
}

void simulation::
cuboids (const cuboids_sequence& s)
{
  this->cuboids_ = s;
}

const simulation::spheres_sequence& simulation::
spheres () const
{
  return this->spheres_;
}

simulation::spheres_sequence& simulation::
spheres ()
{
  return this->spheres_;
}

void simulation::
spheres (const spheres_sequence& s)
{
  this->spheres_ = s;
}

const simulation::membranes_sequence& simulation::
membranes () const
{
  return this->membranes_;
}

simulation::membranes_sequence& simulation::
membranes ()
{
  return this->membranes_;
}

void simulation::
membranes (const membranes_sequence& s)
{
  this->membranes_ = s;
}


// output
// 

const output::base_name_type& output::
base_name () const
{
  return this->base_name_.get ();
}

output::base_name_type& output::
base_name ()
{
  return this->base_name_.get ();
}

void output::
base_name (const base_name_type& x)
{
  this->base_name_.set (x);
}

void output::
base_name (::std::auto_ptr< base_name_type > x)
{
  this->base_name_.set (x);
}

const output::write_frequency_type& output::
write_frequency () const
{
  return this->write_frequency_.get ();
}

output::write_frequency_type& output::
write_frequency ()
{
  return this->write_frequency_.get ();
}

void output::
write_frequency (const write_frequency_type& x)
{
  this->write_frequency_.set (x);
}


// parameters
// 

const parameters::end_t_type& parameters::
end_t () const
{
  return this->end_t_.get ();
}

parameters::end_t_type& parameters::
end_t ()
{
  return this->end_t_.get ();
}

void parameters::
end_t (const end_t_type& x)
{
  this->end_t_.set (x);
}

const parameters::delta_t_type& parameters::
delta_t () const
{
  return this->delta_t_.get ();
}

parameters::delta_t_type& parameters::
delta_t ()
{
  return this->delta_t_.get ();
}

void parameters::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const parameters::cutoff_radius_type& parameters::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

parameters::cutoff_radius_type& parameters::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void parameters::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

const parameters::parallel_strategy_type& parameters::
parallel_strategy () const
{
  return this->parallel_strategy_.get ();
}

parameters::parallel_strategy_type& parameters::
parallel_strategy ()
{
  return this->parallel_strategy_.get ();
}

void parameters::
parallel_strategy (const parallel_strategy_type& x)
{
  this->parallel_strategy_.set (x);
}

void parameters::
parallel_strategy (::std::auto_ptr< parallel_strategy_type > x)
{
  this->parallel_strategy_.set (x);
}


// Forces
// 

const Forces::Force_sequence& Forces::
Force () const
{
  return this->Force_;
}

Forces::Force_sequence& Forces::
Force ()
{
  return this->Force_;
}

void Forces::
Force (const Force_sequence& s)
{
  this->Force_ = s;
}


// ConstantForces
// 

const ConstantForces::ConstantForce_type& ConstantForces::
ConstantForce () const
{
  return this->ConstantForce_.get ();
}

ConstantForces::ConstantForce_type& ConstantForces::
ConstantForce ()
{
  return this->ConstantForce_.get ();
}

void ConstantForces::
ConstantForce (const ConstantForce_type& x)
{
  this->ConstantForce_.set (x);
}

void ConstantForces::
ConstantForce (::std::auto_ptr< ConstantForce_type > x)
{
  this->ConstantForce_.set (x);
}


// Thermostat
// 

const Thermostat::n_thermostats_type& Thermostat::
n_thermostats () const
{
  return this->n_thermostats_.get ();
}

Thermostat::n_thermostats_type& Thermostat::
n_thermostats ()
{
  return this->n_thermostats_.get ();
}

void Thermostat::
n_thermostats (const n_thermostats_type& x)
{
  this->n_thermostats_.set (x);
}

const Thermostat::init_T_type& Thermostat::
init_T () const
{
  return this->init_T_.get ();
}

Thermostat::init_T_type& Thermostat::
init_T ()
{
  return this->init_T_.get ();
}

void Thermostat::
init_T (const init_T_type& x)
{
  this->init_T_.set (x);
}

const Thermostat::target_T_optional& Thermostat::
target_T () const
{
  return this->target_T_;
}

Thermostat::target_T_optional& Thermostat::
target_T ()
{
  return this->target_T_;
}

void Thermostat::
target_T (const target_T_type& x)
{
  this->target_T_.set (x);
}

void Thermostat::
target_T (const target_T_optional& x)
{
  this->target_T_ = x;
}

Thermostat::target_T_type Thermostat::
target_T_default_value ()
{
  return target_T_type (-1.0);
}

const Thermostat::temp_dT_optional& Thermostat::
temp_dT () const
{
  return this->temp_dT_;
}

Thermostat::temp_dT_optional& Thermostat::
temp_dT ()
{
  return this->temp_dT_;
}

void Thermostat::
temp_dT (const temp_dT_type& x)
{
  this->temp_dT_.set (x);
}

void Thermostat::
temp_dT (const temp_dT_optional& x)
{
  this->temp_dT_ = x;
}

Thermostat::temp_dT_type Thermostat::
temp_dT_default_value ()
{
  return temp_dT_type (1000.0);
}


// particles
// 

const particles::origin_type& particles::
origin () const
{
  return this->origin_.get ();
}

particles::origin_type& particles::
origin ()
{
  return this->origin_.get ();
}

void particles::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void particles::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const particles::velocity_type& particles::
velocity () const
{
  return this->velocity_.get ();
}

particles::velocity_type& particles::
velocity ()
{
  return this->velocity_.get ();
}

void particles::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void particles::
velocity (::std::auto_ptr< velocity_type > x)
{
  this->velocity_.set (x);
}

const particles::mass_type& particles::
mass () const
{
  return this->mass_.get ();
}

particles::mass_type& particles::
mass ()
{
  return this->mass_.get ();
}

void particles::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const particles::type_type& particles::
type () const
{
  return this->type_.get ();
}

particles::type_type& particles::
type ()
{
  return this->type_.get ();
}

void particles::
type (const type_type& x)
{
  this->type_.set (x);
}

const particles::state_type& particles::
state () const
{
  return this->state_.get ();
}

particles::state_type& particles::
state ()
{
  return this->state_.get ();
}

void particles::
state (const state_type& x)
{
  this->state_.set (x);
}

void particles::
state (::std::auto_ptr< state_type > x)
{
  this->state_.set (x);
}

const particles::state_type& particles::
state_default_value ()
{
  return state_default_value_;
}


// cuboids
// 

const cuboids::origin_type& cuboids::
origin () const
{
  return this->origin_.get ();
}

cuboids::origin_type& cuboids::
origin ()
{
  return this->origin_.get ();
}

void cuboids::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void cuboids::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const cuboids::velocity_type& cuboids::
velocity () const
{
  return this->velocity_.get ();
}

cuboids::velocity_type& cuboids::
velocity ()
{
  return this->velocity_.get ();
}

void cuboids::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboids::
velocity (::std::auto_ptr< velocity_type > x)
{
  this->velocity_.set (x);
}

const cuboids::numPart_type& cuboids::
numPart () const
{
  return this->numPart_.get ();
}

cuboids::numPart_type& cuboids::
numPart ()
{
  return this->numPart_.get ();
}

void cuboids::
numPart (const numPart_type& x)
{
  this->numPart_.set (x);
}

void cuboids::
numPart (::std::auto_ptr< numPart_type > x)
{
  this->numPart_.set (x);
}

const cuboids::thermal_v_type& cuboids::
thermal_v () const
{
  return this->thermal_v_.get ();
}

cuboids::thermal_v_type& cuboids::
thermal_v ()
{
  return this->thermal_v_.get ();
}

void cuboids::
thermal_v (const thermal_v_type& x)
{
  this->thermal_v_.set (x);
}

cuboids::thermal_v_type cuboids::
thermal_v_default_value ()
{
  return thermal_v_type (0.0);
}

const cuboids::width_type& cuboids::
width () const
{
  return this->width_.get ();
}

cuboids::width_type& cuboids::
width ()
{
  return this->width_.get ();
}

void cuboids::
width (const width_type& x)
{
  this->width_.set (x);
}

const cuboids::mass_type& cuboids::
mass () const
{
  return this->mass_.get ();
}

cuboids::mass_type& cuboids::
mass ()
{
  return this->mass_.get ();
}

void cuboids::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboids::dimension_type& cuboids::
dimension () const
{
  return this->dimension_.get ();
}

cuboids::dimension_type& cuboids::
dimension ()
{
  return this->dimension_.get ();
}

void cuboids::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

void cuboids::
dimension (::std::auto_ptr< dimension_type > x)
{
  this->dimension_.set (x);
}

const cuboids::type_type& cuboids::
type () const
{
  return this->type_.get ();
}

cuboids::type_type& cuboids::
type ()
{
  return this->type_.get ();
}

void cuboids::
type (const type_type& x)
{
  this->type_.set (x);
}

cuboids::type_type cuboids::
type_default_value ()
{
  return type_type (0);
}

const cuboids::state_type& cuboids::
state () const
{
  return this->state_.get ();
}

cuboids::state_type& cuboids::
state ()
{
  return this->state_.get ();
}

void cuboids::
state (const state_type& x)
{
  this->state_.set (x);
}

void cuboids::
state (::std::auto_ptr< state_type > x)
{
  this->state_.set (x);
}

const cuboids::state_type& cuboids::
state_default_value ()
{
  return state_default_value_;
}


// spheres
// 

const spheres::origin_type& spheres::
origin () const
{
  return this->origin_.get ();
}

spheres::origin_type& spheres::
origin ()
{
  return this->origin_.get ();
}

void spheres::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void spheres::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const spheres::velocity_type& spheres::
velocity () const
{
  return this->velocity_.get ();
}

spheres::velocity_type& spheres::
velocity ()
{
  return this->velocity_.get ();
}

void spheres::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void spheres::
velocity (::std::auto_ptr< velocity_type > x)
{
  this->velocity_.set (x);
}

const spheres::thermal_v_type& spheres::
thermal_v () const
{
  return this->thermal_v_.get ();
}

spheres::thermal_v_type& spheres::
thermal_v ()
{
  return this->thermal_v_.get ();
}

void spheres::
thermal_v (const thermal_v_type& x)
{
  this->thermal_v_.set (x);
}

spheres::thermal_v_type spheres::
thermal_v_default_value ()
{
  return thermal_v_type (0.0);
}

const spheres::radius_type& spheres::
radius () const
{
  return this->radius_.get ();
}

spheres::radius_type& spheres::
radius ()
{
  return this->radius_.get ();
}

void spheres::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const spheres::width_type& spheres::
width () const
{
  return this->width_.get ();
}

spheres::width_type& spheres::
width ()
{
  return this->width_.get ();
}

void spheres::
width (const width_type& x)
{
  this->width_.set (x);
}

const spheres::mass_type& spheres::
mass () const
{
  return this->mass_.get ();
}

spheres::mass_type& spheres::
mass ()
{
  return this->mass_.get ();
}

void spheres::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const spheres::dimension_type& spheres::
dimension () const
{
  return this->dimension_.get ();
}

spheres::dimension_type& spheres::
dimension ()
{
  return this->dimension_.get ();
}

void spheres::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

void spheres::
dimension (::std::auto_ptr< dimension_type > x)
{
  this->dimension_.set (x);
}

const spheres::type_type& spheres::
type () const
{
  return this->type_.get ();
}

spheres::type_type& spheres::
type ()
{
  return this->type_.get ();
}

void spheres::
type (const type_type& x)
{
  this->type_.set (x);
}

spheres::type_type spheres::
type_default_value ()
{
  return type_type (0);
}

const spheres::state_type& spheres::
state () const
{
  return this->state_.get ();
}

spheres::state_type& spheres::
state ()
{
  return this->state_.get ();
}

void spheres::
state (const state_type& x)
{
  this->state_.set (x);
}

void spheres::
state (::std::auto_ptr< state_type > x)
{
  this->state_.set (x);
}

const spheres::state_type& spheres::
state_default_value ()
{
  return state_default_value_;
}


// membranes
// 

const membranes::origin_type& membranes::
origin () const
{
  return this->origin_.get ();
}

membranes::origin_type& membranes::
origin ()
{
  return this->origin_.get ();
}

void membranes::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void membranes::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const membranes::velocity_type& membranes::
velocity () const
{
  return this->velocity_.get ();
}

membranes::velocity_type& membranes::
velocity ()
{
  return this->velocity_.get ();
}

void membranes::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void membranes::
velocity (::std::auto_ptr< velocity_type > x)
{
  this->velocity_.set (x);
}

const membranes::numPart_type& membranes::
numPart () const
{
  return this->numPart_.get ();
}

membranes::numPart_type& membranes::
numPart ()
{
  return this->numPart_.get ();
}

void membranes::
numPart (const numPart_type& x)
{
  this->numPart_.set (x);
}

void membranes::
numPart (::std::auto_ptr< numPart_type > x)
{
  this->numPart_.set (x);
}

const membranes::width_type& membranes::
width () const
{
  return this->width_.get ();
}

membranes::width_type& membranes::
width ()
{
  return this->width_.get ();
}

void membranes::
width (const width_type& x)
{
  this->width_.set (x);
}

const membranes::mass_type& membranes::
mass () const
{
  return this->mass_.get ();
}

membranes::mass_type& membranes::
mass ()
{
  return this->mass_.get ();
}

void membranes::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const membranes::k_type& membranes::
k () const
{
  return this->k_.get ();
}

membranes::k_type& membranes::
k ()
{
  return this->k_.get ();
}

void membranes::
k (const k_type& x)
{
  this->k_.set (x);
}

const membranes::type_type& membranes::
type () const
{
  return this->type_.get ();
}

membranes::type_type& membranes::
type ()
{
  return this->type_.get ();
}

void membranes::
type (const type_type& x)
{
  this->type_.set (x);
}

membranes::type_type membranes::
type_default_value ()
{
  return type_type (0);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Vec3Type_base
//

Vec3Type_base::
Vec3Type_base (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
{
}

Vec3Type_base::
Vec3Type_base (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
{
}

Vec3Type_base::
Vec3Type_base (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
{
}

Vec3Type_base* Vec3Type_base::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vec3Type_base (*this, f, c);
}

Vec3Type_base::
~Vec3Type_base ()
{
}

// Vec3Type
//

Vec3Type::
Vec3Type ()
: ::Vec3Type_base ()
{
}

Vec3Type::
Vec3Type (const ::Vec3Type_base& _xsd_Vec3Type_base_base)
: ::Vec3Type_base (_xsd_Vec3Type_base_base)
{
}

Vec3Type::
Vec3Type (const Vec3Type& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Vec3Type_base (x, f, c)
{
}

Vec3Type::
Vec3Type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Vec3Type_base (e, f, c)
{
}

Vec3Type::
Vec3Type (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Vec3Type_base (a, f, c)
{
}

Vec3Type::
Vec3Type (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Vec3Type_base (s, e, f, c)
{
}

Vec3Type* Vec3Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vec3Type (*this, f, c);
}

Vec3Type::
~Vec3Type ()
{
}

// Int3Type_base
//

Int3Type_base::
Int3Type_base (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
{
}

Int3Type_base::
Int3Type_base (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
{
}

Int3Type_base::
Int3Type_base (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
{
}

Int3Type_base* Int3Type_base::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Int3Type_base (*this, f, c);
}

Int3Type_base::
~Int3Type_base ()
{
}

// Int3Type
//

Int3Type::
Int3Type ()
: ::Int3Type_base ()
{
}

Int3Type::
Int3Type (const ::Int3Type_base& _xsd_Int3Type_base_base)
: ::Int3Type_base (_xsd_Int3Type_base_base)
{
}

Int3Type::
Int3Type (const Int3Type& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Int3Type_base (x, f, c)
{
}

Int3Type::
Int3Type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Int3Type_base (e, f, c)
{
}

Int3Type::
Int3Type (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Int3Type_base (a, f, c)
{
}

Int3Type::
Int3Type (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Int3Type_base (s, e, f, c)
{
}

Int3Type* Int3Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Int3Type (*this, f, c);
}

Int3Type::
~Int3Type ()
{
}

// DimensionType
//

DimensionType::
DimensionType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
{
}

DimensionType::
DimensionType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
{
}

DimensionType::
DimensionType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

DimensionType* DimensionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DimensionType (*this, f, c);
}

// ForceType
//

ForceType::
ForceType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType* ForceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceType (*this, f, c);
}

ForceType::value ForceType::
_xsd_ForceType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceType_indexes_,
                    _xsd_ForceType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ForceType_indexes_ + 2 || _xsd_ForceType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceType::
_xsd_ForceType_literals_[2] =
{
  "lennardJones",
  "inverseSquare"
};

const ForceType::value ForceType::
_xsd_ForceType_indexes_[2] =
{
  ::ForceType::inverseSquare,
  ::ForceType::lennardJones
};

// ConstantForceType
//

ConstantForceType::
ConstantForceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ConstantForceType_convert ();
}

ConstantForceType::
ConstantForceType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ConstantForceType_convert ();
}

ConstantForceType::
ConstantForceType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ConstantForceType_convert ();
}

ConstantForceType* ConstantForceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConstantForceType (*this, f, c);
}

ConstantForceType::value ConstantForceType::
_xsd_ConstantForceType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ConstantForceType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ConstantForceType_indexes_,
                    _xsd_ConstantForceType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ConstantForceType_indexes_ + 2 || _xsd_ConstantForceType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ConstantForceType::
_xsd_ConstantForceType_literals_[2] =
{
  "gravity",
  "pullForce"
};

const ConstantForceType::value ConstantForceType::
_xsd_ConstantForceType_indexes_[2] =
{
  ::ConstantForceType::gravity,
  ::ConstantForceType::pullForce
};

// BoundaryType
//

BoundaryType::
BoundaryType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_BoundaryType_convert ();
}

BoundaryType::
BoundaryType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_BoundaryType_convert ();
}

BoundaryType::
BoundaryType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_BoundaryType_convert ();
}

BoundaryType* BoundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoundaryType (*this, f, c);
}

BoundaryType::value BoundaryType::
_xsd_BoundaryType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BoundaryType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_BoundaryType_indexes_,
                    _xsd_BoundaryType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_BoundaryType_indexes_ + 4 || _xsd_BoundaryType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const BoundaryType::
_xsd_BoundaryType_literals_[4] =
{
  "OUTFLOW",
  "VELOCITY_REFLECTION",
  "REPULSIVE_FORCE",
  "PERIODIC"
};

const BoundaryType::value BoundaryType::
_xsd_BoundaryType_indexes_[4] =
{
  ::BoundaryType::OUTFLOW,
  ::BoundaryType::PERIODIC,
  ::BoundaryType::REPULSIVE_FORCE,
  ::BoundaryType::VELOCITY_REFLECTION
};

// ParticleStateType
//

ParticleStateType::
ParticleStateType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ParticleStateType_convert ();
}

ParticleStateType::
ParticleStateType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ParticleStateType_convert ();
}

ParticleStateType::
ParticleStateType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ParticleStateType_convert ();
}

ParticleStateType* ParticleStateType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParticleStateType (*this, f, c);
}

ParticleStateType::value ParticleStateType::
_xsd_ParticleStateType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ParticleStateType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ParticleStateType_indexes_,
                    _xsd_ParticleStateType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ParticleStateType_indexes_ + 2 || _xsd_ParticleStateType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ParticleStateType::
_xsd_ParticleStateType_literals_[2] =
{
  "ALIVE",
  "STATIONARY"
};

const ParticleStateType::value ParticleStateType::
_xsd_ParticleStateType_indexes_[2] =
{
  ::ParticleStateType::ALIVE,
  ::ParticleStateType::STATIONARY
};

// ParallelType
//

ParallelType::
ParallelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ParallelType_convert ();
}

ParallelType::
ParallelType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ParallelType_convert ();
}

ParallelType::
ParallelType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ParallelType_convert ();
}

ParallelType* ParallelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParallelType (*this, f, c);
}

ParallelType::value ParallelType::
_xsd_ParallelType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ParallelType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ParallelType_indexes_,
                    _xsd_ParallelType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ParallelType_indexes_ + 3 || _xsd_ParallelType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ParallelType::
_xsd_ParallelType_literals_[3] =
{
  "NONE",
  "CELL_LOCK",
  "SPATIAL_DECOMPOSITION"
};

const ParallelType::value ParallelType::
_xsd_ParallelType_indexes_[3] =
{
  ::ParallelType::CELL_LOCK,
  ::ParallelType::NONE,
  ::ParallelType::SPATIAL_DECOMPOSITION
};

// Force
//

Force::
Force (const type_type& type,
       const partType_type& partType)
: ::xml_schema::type (),
  type_ (type, this),
  partType_ (partType, this),
  arg1_ (this),
  arg2_ (this)
{
}

Force::
Force (const Force& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  partType_ (x.partType_, f, this),
  arg1_ (x.arg1_, f, this),
  arg2_ (x.arg2_, f, this)
{
}

Force::
Force (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  partType_ (this),
  arg1_ (this),
  arg2_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Force::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "partType" && n.namespace_ ().empty ())
    {
      this->partType_.set (partType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "arg1" && n.namespace_ ().empty ())
    {
      this->arg1_.set (arg1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "arg2" && n.namespace_ ().empty ())
    {
      this->arg2_.set (arg2_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!partType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "partType",
      "");
  }
}

Force* Force::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Force (*this, f, c);
}

Force& Force::
operator= (const Force& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->partType_ = x.partType_;
    this->arg1_ = x.arg1_;
    this->arg2_ = x.arg2_;
  }

  return *this;
}

Force::
~Force ()
{
}

// ConstantForce
//

ConstantForce::
ConstantForce (const type_type& type,
               const direction_type& direction,
               const strength_type& strength)
: ::xml_schema::type (),
  type_ (type, this),
  direction_ (direction, this),
  strength_ (strength, this),
  MarkBoxVec1_ (this),
  MarkBoxVec2_ (this),
  start_t_ (start_t_default_value (), this),
  end_t_ (end_t_default_value (), this),
  const_acc_ (const_acc_default_value (), this)
{
}

ConstantForce::
ConstantForce (const ConstantForce& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  direction_ (x.direction_, f, this),
  strength_ (x.strength_, f, this),
  MarkBoxVec1_ (x.MarkBoxVec1_, f, this),
  MarkBoxVec2_ (x.MarkBoxVec2_, f, this),
  start_t_ (x.start_t_, f, this),
  end_t_ (x.end_t_, f, this),
  const_acc_ (x.const_acc_, f, this)
{
}

ConstantForce::
ConstantForce (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  direction_ (this),
  strength_ (this),
  MarkBoxVec1_ (this),
  MarkBoxVec2_ (this),
  start_t_ (this),
  end_t_ (this),
  const_acc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ConstantForce::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "direction" && n.namespace_ ().empty ())
    {
      this->direction_.set (direction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "strength" && n.namespace_ ().empty ())
    {
      this->strength_.set (strength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MarkBoxVec1" && n.namespace_ ().empty ())
    {
      this->MarkBoxVec1_.set (MarkBoxVec1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MarkBoxVec2" && n.namespace_ ().empty ())
    {
      this->MarkBoxVec2_.set (MarkBoxVec2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "start_t" && n.namespace_ ().empty ())
    {
      this->start_t_.set (start_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "end_t" && n.namespace_ ().empty ())
    {
      this->end_t_.set (end_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "const_acc" && n.namespace_ ().empty ())
    {
      this->const_acc_.set (const_acc_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "direction",
      "");
  }

  if (!strength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "strength",
      "");
  }

  if (!start_t_.present ())
  {
    this->start_t_.set (start_t_default_value ());
  }

  if (!end_t_.present ())
  {
    this->end_t_.set (end_t_default_value ());
  }

  if (!const_acc_.present ())
  {
    this->const_acc_.set (const_acc_default_value ());
  }
}

ConstantForce* ConstantForce::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConstantForce (*this, f, c);
}

ConstantForce& ConstantForce::
operator= (const ConstantForce& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->direction_ = x.direction_;
    this->strength_ = x.strength_;
    this->MarkBoxVec1_ = x.MarkBoxVec1_;
    this->MarkBoxVec2_ = x.MarkBoxVec2_;
    this->start_t_ = x.start_t_;
    this->end_t_ = x.end_t_;
    this->const_acc_ = x.const_acc_;
  }

  return *this;
}

ConstantForce::
~ConstantForce ()
{
}

// Boundary
//

Boundary::
Boundary (const typeLEFT_type& typeLEFT,
          const typeRIGHT_type& typeRIGHT,
          const typeTOP_type& typeTOP,
          const typeBOTTOM_type& typeBOTTOM,
          const typeFRONT_type& typeFRONT,
          const typeBACK_type& typeBACK,
          const origin_type& origin,
          const extent_type& extent,
          const grid_constant_type& grid_constant)
: ::xml_schema::type (),
  typeLEFT_ (typeLEFT, this),
  typeRIGHT_ (typeRIGHT, this),
  typeTOP_ (typeTOP, this),
  typeBOTTOM_ (typeBOTTOM, this),
  typeFRONT_ (typeFRONT, this),
  typeBACK_ (typeBACK, this),
  origin_ (origin, this),
  extent_ (extent, this),
  grid_constant_ (grid_constant, this),
  force_type_ (this),
  force_arg1_ (this),
  force_arg2_ (this)
{
}

Boundary::
Boundary (const Boundary& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  typeLEFT_ (x.typeLEFT_, f, this),
  typeRIGHT_ (x.typeRIGHT_, f, this),
  typeTOP_ (x.typeTOP_, f, this),
  typeBOTTOM_ (x.typeBOTTOM_, f, this),
  typeFRONT_ (x.typeFRONT_, f, this),
  typeBACK_ (x.typeBACK_, f, this),
  origin_ (x.origin_, f, this),
  extent_ (x.extent_, f, this),
  grid_constant_ (x.grid_constant_, f, this),
  force_type_ (x.force_type_, f, this),
  force_arg1_ (x.force_arg1_, f, this),
  force_arg2_ (x.force_arg2_, f, this)
{
}

Boundary::
Boundary (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  typeLEFT_ (this),
  typeRIGHT_ (this),
  typeTOP_ (this),
  typeBOTTOM_ (this),
  typeFRONT_ (this),
  typeBACK_ (this),
  origin_ (this),
  extent_ (this),
  grid_constant_ (this),
  force_type_ (this),
  force_arg1_ (this),
  force_arg2_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Boundary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "typeLEFT" && n.namespace_ ().empty ())
    {
      this->typeLEFT_.set (typeLEFT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeRIGHT" && n.namespace_ ().empty ())
    {
      this->typeRIGHT_.set (typeRIGHT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeTOP" && n.namespace_ ().empty ())
    {
      this->typeTOP_.set (typeTOP_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeBOTTOM" && n.namespace_ ().empty ())
    {
      this->typeBOTTOM_.set (typeBOTTOM_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeFRONT" && n.namespace_ ().empty ())
    {
      this->typeFRONT_.set (typeFRONT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeBACK" && n.namespace_ ().empty ())
    {
      this->typeBACK_.set (typeBACK_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      this->origin_.set (origin_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "extent" && n.namespace_ ().empty ())
    {
      this->extent_.set (extent_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "grid_constant" && n.namespace_ ().empty ())
    {
      this->grid_constant_.set (grid_constant_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "force_type" && n.namespace_ ().empty ())
    {
      this->force_type_.set (force_type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "force_arg1" && n.namespace_ ().empty ())
    {
      this->force_arg1_.set (force_arg1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "force_arg2" && n.namespace_ ().empty ())
    {
      this->force_arg2_.set (force_arg2_traits::create (i, f, this));
      continue;
    }
  }

  if (!typeLEFT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeLEFT",
      "");
  }

  if (!typeRIGHT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeRIGHT",
      "");
  }

  if (!typeTOP_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeTOP",
      "");
  }

  if (!typeBOTTOM_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeBOTTOM",
      "");
  }

  if (!typeFRONT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeFRONT",
      "");
  }

  if (!typeBACK_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeBACK",
      "");
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "origin",
      "");
  }

  if (!extent_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "extent",
      "");
  }

  if (!grid_constant_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "grid_constant",
      "");
  }
}

Boundary* Boundary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Boundary (*this, f, c);
}

Boundary& Boundary::
operator= (const Boundary& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->typeLEFT_ = x.typeLEFT_;
    this->typeRIGHT_ = x.typeRIGHT_;
    this->typeTOP_ = x.typeTOP_;
    this->typeBOTTOM_ = x.typeBOTTOM_;
    this->typeFRONT_ = x.typeFRONT_;
    this->typeBACK_ = x.typeBACK_;
    this->origin_ = x.origin_;
    this->extent_ = x.extent_;
    this->grid_constant_ = x.grid_constant_;
    this->force_type_ = x.force_type_;
    this->force_arg1_ = x.force_arg1_;
    this->force_arg2_ = x.force_arg2_;
  }

  return *this;
}

Boundary::
~Boundary ()
{
}

// simulation
//

simulation::
simulation (const output_type& output,
            const parameters_type& parameters,
            const Boundary_type& Boundary,
            const Forces_type& Forces)
: ::xml_schema::type (),
  output_ (output, this),
  parameters_ (parameters, this),
  Boundary_ (Boundary, this),
  Forces_ (Forces, this),
  ConstantForces_ (this),
  Thermostat_ (this),
  particles_ (this),
  cuboids_ (this),
  spheres_ (this),
  membranes_ (this)
{
}

simulation::
simulation (::std::auto_ptr< output_type > output,
            ::std::auto_ptr< parameters_type > parameters,
            ::std::auto_ptr< Boundary_type > Boundary,
            ::std::auto_ptr< Forces_type > Forces)
: ::xml_schema::type (),
  output_ (output, this),
  parameters_ (parameters, this),
  Boundary_ (Boundary, this),
  Forces_ (Forces, this),
  ConstantForces_ (this),
  Thermostat_ (this),
  particles_ (this),
  cuboids_ (this),
  spheres_ (this),
  membranes_ (this)
{
}

simulation::
simulation (const simulation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  output_ (x.output_, f, this),
  parameters_ (x.parameters_, f, this),
  Boundary_ (x.Boundary_, f, this),
  Forces_ (x.Forces_, f, this),
  ConstantForces_ (x.ConstantForces_, f, this),
  Thermostat_ (x.Thermostat_, f, this),
  particles_ (x.particles_, f, this),
  cuboids_ (x.cuboids_, f, this),
  spheres_ (x.spheres_, f, this),
  membranes_ (x.membranes_, f, this)
{
}

simulation::
simulation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  output_ (this),
  parameters_ (this),
  Boundary_ (this),
  Forces_ (this),
  ConstantForces_ (this),
  Thermostat_ (this),
  particles_ (this),
  cuboids_ (this),
  spheres_ (this),
  membranes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (r);
        continue;
      }
    }

    // parameters
    //
    if (n.name () == "parameters" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parameters_type > r (
        parameters_traits::create (i, f, this));

      if (!parameters_.present ())
      {
        this->parameters_.set (r);
        continue;
      }
    }

    // Boundary
    //
    if (n.name () == "Boundary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Boundary_type > r (
        Boundary_traits::create (i, f, this));

      if (!Boundary_.present ())
      {
        this->Boundary_.set (r);
        continue;
      }
    }

    // Forces
    //
    if (n.name () == "Forces" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Forces_type > r (
        Forces_traits::create (i, f, this));

      if (!Forces_.present ())
      {
        this->Forces_.set (r);
        continue;
      }
    }

    // ConstantForces
    //
    if (n.name () == "ConstantForces" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ConstantForces_type > r (
        ConstantForces_traits::create (i, f, this));

      this->ConstantForces_.push_back (r);
      continue;
    }

    // Thermostat
    //
    if (n.name () == "Thermostat" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Thermostat_type > r (
        Thermostat_traits::create (i, f, this));

      if (!this->Thermostat_)
      {
        this->Thermostat_.set (r);
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      this->particles_.push_back (r);
      continue;
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      this->cuboids_.push_back (r);
      continue;
    }

    // spheres
    //
    if (n.name () == "spheres" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spheres_type > r (
        spheres_traits::create (i, f, this));

      this->spheres_.push_back (r);
      continue;
    }

    // membranes
    //
    if (n.name () == "membranes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< membranes_type > r (
        membranes_traits::create (i, f, this));

      this->membranes_.push_back (r);
      continue;
    }

    break;
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  if (!parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parameters",
      "");
  }

  if (!Boundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Boundary",
      "");
  }

  if (!Forces_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Forces",
      "");
  }
}

simulation* simulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation (*this, f, c);
}

simulation& simulation::
operator= (const simulation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->output_ = x.output_;
    this->parameters_ = x.parameters_;
    this->Boundary_ = x.Boundary_;
    this->Forces_ = x.Forces_;
    this->ConstantForces_ = x.ConstantForces_;
    this->Thermostat_ = x.Thermostat_;
    this->particles_ = x.particles_;
    this->cuboids_ = x.cuboids_;
    this->spheres_ = x.spheres_;
    this->membranes_ = x.membranes_;
  }

  return *this;
}

simulation::
~simulation ()
{
}

// output
//

output::
output (const base_name_type& base_name,
        const write_frequency_type& write_frequency)
: ::xml_schema::type (),
  base_name_ (base_name, this),
  write_frequency_ (write_frequency, this)
{
}

output::
output (const output& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  base_name_ (x.base_name_, f, this),
  write_frequency_ (x.write_frequency_, f, this)
{
}

output::
output (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  base_name_ (this),
  write_frequency_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void output::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // base_name
    //
    if (n.name () == "base_name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< base_name_type > r (
        base_name_traits::create (i, f, this));

      if (!base_name_.present ())
      {
        this->base_name_.set (r);
        continue;
      }
    }

    // write_frequency
    //
    if (n.name () == "write_frequency" && n.namespace_ ().empty ())
    {
      if (!write_frequency_.present ())
      {
        this->write_frequency_.set (write_frequency_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!base_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "base_name",
      "");
  }

  if (!write_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "write_frequency",
      "");
  }
}

output* output::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output (*this, f, c);
}

output& output::
operator= (const output& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->base_name_ = x.base_name_;
    this->write_frequency_ = x.write_frequency_;
  }

  return *this;
}

output::
~output ()
{
}

// parameters
//

parameters::
parameters (const end_t_type& end_t,
            const delta_t_type& delta_t,
            const cutoff_radius_type& cutoff_radius,
            const parallel_strategy_type& parallel_strategy)
: ::xml_schema::type (),
  end_t_ (end_t, this),
  delta_t_ (delta_t, this),
  cutoff_radius_ (cutoff_radius, this),
  parallel_strategy_ (parallel_strategy, this)
{
}

parameters::
parameters (const parameters& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  end_t_ (x.end_t_, f, this),
  delta_t_ (x.delta_t_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this),
  parallel_strategy_ (x.parallel_strategy_, f, this)
{
}

parameters::
parameters (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  end_t_ (this),
  delta_t_ (this),
  cutoff_radius_ (this),
  parallel_strategy_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // end_t
    //
    if (n.name () == "end_t" && n.namespace_ ().empty ())
    {
      if (!end_t_.present ())
      {
        this->end_t_.set (end_t_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    // parallel_strategy
    //
    if (n.name () == "parallel_strategy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parallel_strategy_type > r (
        parallel_strategy_traits::create (i, f, this));

      if (!parallel_strategy_.present ())
      {
        this->parallel_strategy_.set (r);
        continue;
      }
    }

    break;
  }

  if (!end_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "end_t",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }

  if (!parallel_strategy_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parallel_strategy",
      "");
  }
}

parameters* parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parameters (*this, f, c);
}

parameters& parameters::
operator= (const parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->end_t_ = x.end_t_;
    this->delta_t_ = x.delta_t_;
    this->cutoff_radius_ = x.cutoff_radius_;
    this->parallel_strategy_ = x.parallel_strategy_;
  }

  return *this;
}

parameters::
~parameters ()
{
}

// Forces
//

Forces::
Forces ()
: ::xml_schema::type (),
  Force_ (this)
{
}

Forces::
Forces (const Forces& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Force_ (x.Force_, f, this)
{
}

Forces::
Forces (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Force_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Forces::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Force
    //
    if (n.name () == "Force" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Force_type > r (
        Force_traits::create (i, f, this));

      this->Force_.push_back (r);
      continue;
    }

    break;
  }
}

Forces* Forces::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Forces (*this, f, c);
}

Forces& Forces::
operator= (const Forces& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Force_ = x.Force_;
  }

  return *this;
}

Forces::
~Forces ()
{
}

// ConstantForces
//

ConstantForces::
ConstantForces (const ConstantForce_type& ConstantForce)
: ::xml_schema::type (),
  ConstantForce_ (ConstantForce, this)
{
}

ConstantForces::
ConstantForces (::std::auto_ptr< ConstantForce_type > ConstantForce)
: ::xml_schema::type (),
  ConstantForce_ (ConstantForce, this)
{
}

ConstantForces::
ConstantForces (const ConstantForces& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ConstantForce_ (x.ConstantForce_, f, this)
{
}

ConstantForces::
ConstantForces (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ConstantForce_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConstantForces::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ConstantForce
    //
    if (n.name () == "ConstantForce" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ConstantForce_type > r (
        ConstantForce_traits::create (i, f, this));

      if (!ConstantForce_.present ())
      {
        this->ConstantForce_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ConstantForce_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ConstantForce",
      "");
  }
}

ConstantForces* ConstantForces::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConstantForces (*this, f, c);
}

ConstantForces& ConstantForces::
operator= (const ConstantForces& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ConstantForce_ = x.ConstantForce_;
  }

  return *this;
}

ConstantForces::
~ConstantForces ()
{
}

// Thermostat
//

Thermostat::
Thermostat (const n_thermostats_type& n_thermostats,
            const init_T_type& init_T)
: ::xml_schema::type (),
  n_thermostats_ (n_thermostats, this),
  init_T_ (init_T, this),
  target_T_ (this),
  temp_dT_ (this)
{
}

Thermostat::
Thermostat (const Thermostat& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  n_thermostats_ (x.n_thermostats_, f, this),
  init_T_ (x.init_T_, f, this),
  target_T_ (x.target_T_, f, this),
  temp_dT_ (x.temp_dT_, f, this)
{
}

Thermostat::
Thermostat (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  n_thermostats_ (this),
  init_T_ (this),
  target_T_ (this),
  temp_dT_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Thermostat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // n_thermostats
    //
    if (n.name () == "n_thermostats" && n.namespace_ ().empty ())
    {
      if (!n_thermostats_.present ())
      {
        this->n_thermostats_.set (n_thermostats_traits::create (i, f, this));
        continue;
      }
    }

    // init_T
    //
    if (n.name () == "init_T" && n.namespace_ ().empty ())
    {
      if (!init_T_.present ())
      {
        this->init_T_.set (init_T_traits::create (i, f, this));
        continue;
      }
    }

    // target_T
    //
    if (n.name () == "target_T" && n.namespace_ ().empty ())
    {
      if (!this->target_T_)
      {
        this->target_T_.set (target_T_traits::create (i, f, this));
        continue;
      }
    }

    // temp_dT
    //
    if (n.name () == "temp_dT" && n.namespace_ ().empty ())
    {
      if (!this->temp_dT_)
      {
        this->temp_dT_.set (temp_dT_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!n_thermostats_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n_thermostats",
      "");
  }

  if (!init_T_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "init_T",
      "");
  }
}

Thermostat* Thermostat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Thermostat (*this, f, c);
}

Thermostat& Thermostat::
operator= (const Thermostat& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->n_thermostats_ = x.n_thermostats_;
    this->init_T_ = x.init_T_;
    this->target_T_ = x.target_T_;
    this->temp_dT_ = x.temp_dT_;
  }

  return *this;
}

Thermostat::
~Thermostat ()
{
}

// particles
//

const particles::state_type particles::state_default_value_ (
  "ALIVE");

particles::
particles (const origin_type& origin,
           const velocity_type& velocity,
           const mass_type& mass,
           const type_type& type,
           const state_type& state)
: ::xml_schema::type (),
  origin_ (origin, this),
  velocity_ (velocity, this),
  mass_ (mass, this),
  type_ (type, this),
  state_ (state, this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this),
  type_ (x.type_, f, this),
  state_ (x.state_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  velocity_ (this),
  mass_ (this),
  type_ (this),
  state_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (r);
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    // state
    //
    if (n.name () == "state" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< state_type > r (
        state_traits::create (i, f, this));

      if (!state_.present ())
      {
        this->state_.set (r);
        continue;
      }
    }

    break;
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!state_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "state",
      "");
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
    this->type_ = x.type_;
    this->state_ = x.state_;
  }

  return *this;
}

particles::
~particles ()
{
}

// cuboids
//

const cuboids::state_type cuboids::state_default_value_ (
  "ALIVE");

cuboids::
cuboids (const origin_type& origin,
         const velocity_type& velocity,
         const numPart_type& numPart,
         const thermal_v_type& thermal_v,
         const width_type& width,
         const mass_type& mass,
         const dimension_type& dimension,
         const type_type& type,
         const state_type& state)
: ::xml_schema::type (),
  origin_ (origin, this),
  velocity_ (velocity, this),
  numPart_ (numPart, this),
  thermal_v_ (thermal_v, this),
  width_ (width, this),
  mass_ (mass, this),
  dimension_ (dimension, this),
  type_ (type, this),
  state_ (state, this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  velocity_ (x.velocity_, f, this),
  numPart_ (x.numPart_, f, this),
  thermal_v_ (x.thermal_v_, f, this),
  width_ (x.width_, f, this),
  mass_ (x.mass_, f, this),
  dimension_ (x.dimension_, f, this),
  type_ (x.type_, f, this),
  state_ (x.state_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  velocity_ (this),
  numPart_ (this),
  thermal_v_ (this),
  width_ (this),
  mass_ (this),
  dimension_ (this),
  type_ (this),
  state_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (r);
        continue;
      }
    }

    // numPart
    //
    if (n.name () == "numPart" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< numPart_type > r (
        numPart_traits::create (i, f, this));

      if (!numPart_.present ())
      {
        this->numPart_.set (r);
        continue;
      }
    }

    // thermal_v
    //
    if (n.name () == "thermal_v" && n.namespace_ ().empty ())
    {
      if (!thermal_v_.present ())
      {
        this->thermal_v_.set (thermal_v_traits::create (i, f, this));
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      if (!width_.present ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dimension_type > r (
        dimension_traits::create (i, f, this));

      if (!dimension_.present ())
      {
        this->dimension_.set (r);
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    // state
    //
    if (n.name () == "state" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< state_type > r (
        state_traits::create (i, f, this));

      if (!state_.present ())
      {
        this->state_.set (r);
        continue;
      }
    }

    break;
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!numPart_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numPart",
      "");
  }

  if (!thermal_v_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermal_v",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!state_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "state",
      "");
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->velocity_ = x.velocity_;
    this->numPart_ = x.numPart_;
    this->thermal_v_ = x.thermal_v_;
    this->width_ = x.width_;
    this->mass_ = x.mass_;
    this->dimension_ = x.dimension_;
    this->type_ = x.type_;
    this->state_ = x.state_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// spheres
//

const spheres::state_type spheres::state_default_value_ (
  "ALIVE");

spheres::
spheres (const origin_type& origin,
         const velocity_type& velocity,
         const thermal_v_type& thermal_v,
         const radius_type& radius,
         const width_type& width,
         const mass_type& mass,
         const dimension_type& dimension,
         const type_type& type,
         const state_type& state)
: ::xml_schema::type (),
  origin_ (origin, this),
  velocity_ (velocity, this),
  thermal_v_ (thermal_v, this),
  radius_ (radius, this),
  width_ (width, this),
  mass_ (mass, this),
  dimension_ (dimension, this),
  type_ (type, this),
  state_ (state, this)
{
}

spheres::
spheres (const spheres& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  velocity_ (x.velocity_, f, this),
  thermal_v_ (x.thermal_v_, f, this),
  radius_ (x.radius_, f, this),
  width_ (x.width_, f, this),
  mass_ (x.mass_, f, this),
  dimension_ (x.dimension_, f, this),
  type_ (x.type_, f, this),
  state_ (x.state_, f, this)
{
}

spheres::
spheres (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  velocity_ (this),
  thermal_v_ (this),
  radius_ (this),
  width_ (this),
  mass_ (this),
  dimension_ (this),
  type_ (this),
  state_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void spheres::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (r);
        continue;
      }
    }

    // thermal_v
    //
    if (n.name () == "thermal_v" && n.namespace_ ().empty ())
    {
      if (!thermal_v_.present ())
      {
        this->thermal_v_.set (thermal_v_traits::create (i, f, this));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      if (!width_.present ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dimension_type > r (
        dimension_traits::create (i, f, this));

      if (!dimension_.present ())
      {
        this->dimension_.set (r);
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    // state
    //
    if (n.name () == "state" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< state_type > r (
        state_traits::create (i, f, this));

      if (!state_.present ())
      {
        this->state_.set (r);
        continue;
      }
    }

    break;
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!thermal_v_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermal_v",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!state_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "state",
      "");
  }
}

spheres* spheres::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spheres (*this, f, c);
}

spheres& spheres::
operator= (const spheres& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->velocity_ = x.velocity_;
    this->thermal_v_ = x.thermal_v_;
    this->radius_ = x.radius_;
    this->width_ = x.width_;
    this->mass_ = x.mass_;
    this->dimension_ = x.dimension_;
    this->type_ = x.type_;
    this->state_ = x.state_;
  }

  return *this;
}

spheres::
~spheres ()
{
}

// membranes
//

membranes::
membranes (const origin_type& origin,
           const velocity_type& velocity,
           const numPart_type& numPart,
           const width_type& width,
           const mass_type& mass,
           const k_type& k,
           const type_type& type)
: ::xml_schema::type (),
  origin_ (origin, this),
  velocity_ (velocity, this),
  numPart_ (numPart, this),
  width_ (width, this),
  mass_ (mass, this),
  k_ (k, this),
  type_ (type, this)
{
}

membranes::
membranes (const membranes& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  velocity_ (x.velocity_, f, this),
  numPart_ (x.numPart_, f, this),
  width_ (x.width_, f, this),
  mass_ (x.mass_, f, this),
  k_ (x.k_, f, this),
  type_ (x.type_, f, this)
{
}

membranes::
membranes (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (this),
  velocity_ (this),
  numPart_ (this),
  width_ (this),
  mass_ (this),
  k_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void membranes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (r);
        continue;
      }
    }

    // numPart
    //
    if (n.name () == "numPart" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< numPart_type > r (
        numPart_traits::create (i, f, this));

      if (!numPart_.present ())
      {
        this->numPart_.set (r);
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      if (!width_.present ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // k
    //
    if (n.name () == "k" && n.namespace_ ().empty ())
    {
      if (!k_.present ())
      {
        this->k_.set (k_traits::create (i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!numPart_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numPart",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!k_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "k",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }
}

membranes* membranes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class membranes (*this, f, c);
}

membranes& membranes::
operator= (const membranes& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->origin_ = x.origin_;
    this->velocity_ = x.velocity_;
    this->numPart_ = x.numPart_;
    this->width_ = x.width_;
    this->mass_ = x.mass_;
    this->k_ = x.k_;
    this->type_ = x.type_;
  }

  return *this;
}

membranes::
~membranes ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::simulation > (
      ::simulation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::auto_ptr< ::simulation >
simulation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const Vec3Type_base& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Vec3Type_base& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Vec3Type_base& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Vec3Type& i)
{
  e << static_cast< const ::Vec3Type_base& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Vec3Type& i)
{
  a << static_cast< const ::Vec3Type_base& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Vec3Type& i)
{
  l << static_cast< const ::Vec3Type_base& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Int3Type_base& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::int_, char >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Int3Type_base& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::int_, char >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Int3Type_base& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::int_, char >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Int3Type& i)
{
  e << static_cast< const ::Int3Type_base& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const Int3Type& i)
{
  a << static_cast< const ::Int3Type_base& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const Int3Type& i)
{
  l << static_cast< const ::Int3Type_base& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DimensionType& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const DimensionType& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const DimensionType& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ForceType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ConstantForceType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ConstantForceType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ConstantForceType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const BoundaryType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const BoundaryType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const BoundaryType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ParticleStateType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ParticleStateType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ParticleStateType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ParallelType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ParallelType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ParallelType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Force& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // partType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "partType",
        e));

    a << i.partType ();
  }

  // arg1
  //
  if (i.arg1 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "arg1",
        e));

    a << ::xml_schema::as_double(*i.arg1 ());
  }

  // arg2
  //
  if (i.arg2 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "arg2",
        e));

    a << ::xml_schema::as_double(*i.arg2 ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ConstantForce& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // direction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "direction",
        e));

    a << i.direction ();
  }

  // strength
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "strength",
        e));

    a << ::xml_schema::as_double(i.strength ());
  }

  // MarkBoxVec1
  //
  if (i.MarkBoxVec1 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MarkBoxVec1",
        e));

    a << *i.MarkBoxVec1 ();
  }

  // MarkBoxVec2
  //
  if (i.MarkBoxVec2 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MarkBoxVec2",
        e));

    a << *i.MarkBoxVec2 ();
  }

  // start_t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "start_t",
        e));

    a << ::xml_schema::as_double(i.start_t ());
  }

  // end_t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "end_t",
        e));

    a << ::xml_schema::as_double(i.end_t ());
  }

  // const_acc
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "const_acc",
        e));

    a << i.const_acc ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Boundary& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // typeLEFT
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeLEFT",
        e));

    a << i.typeLEFT ();
  }

  // typeRIGHT
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeRIGHT",
        e));

    a << i.typeRIGHT ();
  }

  // typeTOP
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeTOP",
        e));

    a << i.typeTOP ();
  }

  // typeBOTTOM
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeBOTTOM",
        e));

    a << i.typeBOTTOM ();
  }

  // typeFRONT
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeFRONT",
        e));

    a << i.typeFRONT ();
  }

  // typeBACK
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeBACK",
        e));

    a << i.typeBACK ();
  }

  // origin
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "origin",
        e));

    a << i.origin ();
  }

  // extent
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "extent",
        e));

    a << i.extent ();
  }

  // grid_constant
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "grid_constant",
        e));

    a << ::xml_schema::as_double(i.grid_constant ());
  }

  // force_type
  //
  if (i.force_type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "force_type",
        e));

    a << *i.force_type ();
  }

  // force_arg1
  //
  if (i.force_arg1 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "force_arg1",
        e));

    a << ::xml_schema::as_double(*i.force_arg1 ());
  }

  // force_arg2
  //
  if (i.force_arg2 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "force_arg2",
        e));

    a << ::xml_schema::as_double(*i.force_arg2 ());
  }
}

void
simulation_ (::std::ostream& o,
             const ::simulation& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation_ (::std::ostream& o,
             const ::simulation& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::std::ostream& o,
             const ::simulation& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::xercesc::XMLFormatTarget& t,
             const ::simulation& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation_ (::xercesc::XMLFormatTarget& t,
             const ::simulation& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::xercesc::XMLFormatTarget& t,
             const ::simulation& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::xercesc::DOMDocument& d,
             const ::simulation& s,
             ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
simulation_ (const ::simulation& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "simulation",
      "",
      m, f));

  ::simulation_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const simulation& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // output
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "output",
        e));

    s << i.output ();
  }

  // parameters
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "parameters",
        e));

    s << i.parameters ();
  }

  // Boundary
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Boundary",
        e));

    s << i.Boundary ();
  }

  // Forces
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Forces",
        e));

    s << i.Forces ();
  }

  // ConstantForces
  //
  for (simulation::ConstantForces_const_iterator
       b (i.ConstantForces ().begin ()), n (i.ConstantForces ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ConstantForces",
        e));

    s << *b;
  }

  // Thermostat
  //
  if (i.Thermostat ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Thermostat",
        e));

    s << *i.Thermostat ();
  }

  // particles
  //
  for (simulation::particles_const_iterator
       b (i.particles ().begin ()), n (i.particles ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particles",
        e));

    s << *b;
  }

  // cuboids
  //
  for (simulation::cuboids_const_iterator
       b (i.cuboids ().begin ()), n (i.cuboids ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cuboids",
        e));

    s << *b;
  }

  // spheres
  //
  for (simulation::spheres_const_iterator
       b (i.spheres ().begin ()), n (i.spheres ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spheres",
        e));

    s << *b;
  }

  // membranes
  //
  for (simulation::membranes_const_iterator
       b (i.membranes ().begin ()), n (i.membranes ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "membranes",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const output& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // base_name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "base_name",
        e));

    s << i.base_name ();
  }

  // write_frequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "write_frequency",
        e));

    s << i.write_frequency ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const parameters& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // end_t
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "end_t",
        e));

    s << ::xml_schema::as_double(i.end_t ());
  }

  // delta_t
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "delta_t",
        e));

    s << ::xml_schema::as_double(i.delta_t ());
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cutoff_radius",
        e));

    s << ::xml_schema::as_double(i.cutoff_radius ());
  }

  // parallel_strategy
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "parallel_strategy",
        e));

    s << i.parallel_strategy ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Forces& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Force
  //
  for (Forces::Force_const_iterator
       b (i.Force ().begin ()), n (i.Force ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Force",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ConstantForces& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ConstantForce
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ConstantForce",
        e));

    s << i.ConstantForce ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Thermostat& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // n_thermostats
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "n_thermostats",
        e));

    s << i.n_thermostats ();
  }

  // init_T
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "init_T",
        e));

    s << ::xml_schema::as_double(i.init_T ());
  }

  // target_T
  //
  if (i.target_T ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "target_T",
        e));

    s << ::xml_schema::as_double(*i.target_T ());
  }

  // temp_dT
  //
  if (i.temp_dT ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "temp_dT",
        e));

    s << ::xml_schema::as_double(*i.temp_dT ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const particles& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "origin",
        e));

    s << i.origin ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_double(i.mass ());
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << i.type ();
  }

  // state
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "state",
        e));

    s << i.state ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const cuboids& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "origin",
        e));

    s << i.origin ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // numPart
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numPart",
        e));

    s << i.numPart ();
  }

  // thermal_v
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "thermal_v",
        e));

    s << ::xml_schema::as_double(i.thermal_v ());
  }

  // width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "width",
        e));

    s << ::xml_schema::as_double(i.width ());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_double(i.mass ());
  }

  // dimension
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dimension",
        e));

    s << i.dimension ();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << i.type ();
  }

  // state
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "state",
        e));

    s << i.state ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const spheres& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "origin",
        e));

    s << i.origin ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // thermal_v
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "thermal_v",
        e));

    s << ::xml_schema::as_double(i.thermal_v ());
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }

  // width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "width",
        e));

    s << ::xml_schema::as_double(i.width ());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_double(i.mass ());
  }

  // dimension
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dimension",
        e));

    s << i.dimension ();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << i.type ();
  }

  // state
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "state",
        e));

    s << i.state ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const membranes& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "origin",
        e));

    s << i.origin ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // numPart
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numPart",
        e));

    s << i.numPart ();
  }

  // width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "width",
        e));

    s << ::xml_schema::as_double(i.width ());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_double(i.mass ());
  }

  // k
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "k",
        e));

    s << ::xml_schema::as_double(i.k ());
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << i.type ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

