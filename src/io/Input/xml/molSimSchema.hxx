// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MOL_SIM_SCHEMA_HXX
#define MOL_SIM_SCHEMA_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class DimensionT;
class ForceType;
class Force;
class BoundaryType;
class Boundary;
class simulation;
class output;
class parameters;
class particles;
class Forces;
class Thermostat;
class cuboids;
class spheres;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class DimensionT: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
{
  public:
  DimensionT (::xml_schema::int_ v);

  DimensionT (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  DimensionT (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  DimensionT (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  DimensionT (const DimensionT& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual DimensionT*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class ForceType: public ::xml_schema::string
{
  public:
  enum value
  {
    lennardJones,
    inverseSquare,
    HooksLaw
  };

  ForceType (value v);

  ForceType (const char* v);

  ForceType (const ::std::string& v);

  ForceType (const ::xml_schema::string& v);

  ForceType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ForceType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ForceType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ForceType (const ForceType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual ForceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ForceType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ForceType_convert ();
  }

  protected:
  value
  _xsd_ForceType_convert () const;

  public:
  static const char* const _xsd_ForceType_literals_[3];
  static const value _xsd_ForceType_indexes_[3];
};

class Force: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::ForceType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // arg1
  //
  typedef ::xml_schema::double_ arg1_type;
  typedef ::xsd::cxx::tree::optional< arg1_type > arg1_optional;
  typedef ::xsd::cxx::tree::traits< arg1_type, char, ::xsd::cxx::tree::schema_type::double_ > arg1_traits;

  const arg1_optional&
  arg1 () const;

  arg1_optional&
  arg1 ();

  void
  arg1 (const arg1_type& x);

  void
  arg1 (const arg1_optional& x);

  // arg2
  //
  typedef ::xml_schema::double_ arg2_type;
  typedef ::xsd::cxx::tree::optional< arg2_type > arg2_optional;
  typedef ::xsd::cxx::tree::traits< arg2_type, char, ::xsd::cxx::tree::schema_type::double_ > arg2_traits;

  const arg2_optional&
  arg2 () const;

  arg2_optional&
  arg2 ();

  void
  arg2 (const arg2_type& x);

  void
  arg2 (const arg2_optional& x);

  // Constructors.
  //
  Force (const type_type&);

  Force (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Force (const Force& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Force*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Force&
  operator= (const Force& x);

  virtual 
  ~Force ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
  arg1_optional arg1_;
  arg2_optional arg2_;
};

class BoundaryType: public ::xml_schema::string
{
  public:
  enum value
  {
    OUTFLOW,
    VELOCITY_REFLECTION,
    REPULSIVE_FORCE,
    PERIODIC
  };

  BoundaryType (value v);

  BoundaryType (const char* v);

  BoundaryType (const ::std::string& v);

  BoundaryType (const ::xml_schema::string& v);

  BoundaryType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoundaryType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoundaryType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoundaryType (const BoundaryType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual BoundaryType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BoundaryType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_BoundaryType_convert ();
  }

  protected:
  value
  _xsd_BoundaryType_convert () const;

  public:
  static const char* const _xsd_BoundaryType_literals_[4];
  static const value _xsd_BoundaryType_indexes_[4];
};

class Boundary: public ::xml_schema::type
{
  public:
  // typeLEFT
  //
  typedef ::BoundaryType typeLEFT_type;
  typedef ::xsd::cxx::tree::traits< typeLEFT_type, char > typeLEFT_traits;

  const typeLEFT_type&
  typeLEFT () const;

  typeLEFT_type&
  typeLEFT ();

  void
  typeLEFT (const typeLEFT_type& x);

  void
  typeLEFT (::std::auto_ptr< typeLEFT_type > p);

  // typeRIGHT
  //
  typedef ::BoundaryType typeRIGHT_type;
  typedef ::xsd::cxx::tree::traits< typeRIGHT_type, char > typeRIGHT_traits;

  const typeRIGHT_type&
  typeRIGHT () const;

  typeRIGHT_type&
  typeRIGHT ();

  void
  typeRIGHT (const typeRIGHT_type& x);

  void
  typeRIGHT (::std::auto_ptr< typeRIGHT_type > p);

  // typeTOP
  //
  typedef ::BoundaryType typeTOP_type;
  typedef ::xsd::cxx::tree::traits< typeTOP_type, char > typeTOP_traits;

  const typeTOP_type&
  typeTOP () const;

  typeTOP_type&
  typeTOP ();

  void
  typeTOP (const typeTOP_type& x);

  void
  typeTOP (::std::auto_ptr< typeTOP_type > p);

  // typeBOTTOM
  //
  typedef ::BoundaryType typeBOTTOM_type;
  typedef ::xsd::cxx::tree::traits< typeBOTTOM_type, char > typeBOTTOM_traits;

  const typeBOTTOM_type&
  typeBOTTOM () const;

  typeBOTTOM_type&
  typeBOTTOM ();

  void
  typeBOTTOM (const typeBOTTOM_type& x);

  void
  typeBOTTOM (::std::auto_ptr< typeBOTTOM_type > p);

  // typeFRONT
  //
  typedef ::BoundaryType typeFRONT_type;
  typedef ::xsd::cxx::tree::traits< typeFRONT_type, char > typeFRONT_traits;

  const typeFRONT_type&
  typeFRONT () const;

  typeFRONT_type&
  typeFRONT ();

  void
  typeFRONT (const typeFRONT_type& x);

  void
  typeFRONT (::std::auto_ptr< typeFRONT_type > p);

  // typeBACK
  //
  typedef ::BoundaryType typeBACK_type;
  typedef ::xsd::cxx::tree::traits< typeBACK_type, char > typeBACK_traits;

  const typeBACK_type&
  typeBACK () const;

  typeBACK_type&
  typeBACK ();

  void
  typeBACK (const typeBACK_type& x);

  void
  typeBACK (::std::auto_ptr< typeBACK_type > p);

  // CENTER_BOUNDARY_ORIGINX
  //
  typedef ::xml_schema::double_ CENTER_BOUNDARY_ORIGINX_type;
  typedef ::xsd::cxx::tree::optional< CENTER_BOUNDARY_ORIGINX_type > CENTER_BOUNDARY_ORIGINX_optional;
  typedef ::xsd::cxx::tree::traits< CENTER_BOUNDARY_ORIGINX_type, char, ::xsd::cxx::tree::schema_type::double_ > CENTER_BOUNDARY_ORIGINX_traits;

  const CENTER_BOUNDARY_ORIGINX_optional&
  CENTER_BOUNDARY_ORIGINX () const;

  CENTER_BOUNDARY_ORIGINX_optional&
  CENTER_BOUNDARY_ORIGINX ();

  void
  CENTER_BOUNDARY_ORIGINX (const CENTER_BOUNDARY_ORIGINX_type& x);

  void
  CENTER_BOUNDARY_ORIGINX (const CENTER_BOUNDARY_ORIGINX_optional& x);

  // CENTER_BOUNDARY_ORIGINY
  //
  typedef ::xml_schema::double_ CENTER_BOUNDARY_ORIGINY_type;
  typedef ::xsd::cxx::tree::optional< CENTER_BOUNDARY_ORIGINY_type > CENTER_BOUNDARY_ORIGINY_optional;
  typedef ::xsd::cxx::tree::traits< CENTER_BOUNDARY_ORIGINY_type, char, ::xsd::cxx::tree::schema_type::double_ > CENTER_BOUNDARY_ORIGINY_traits;

  const CENTER_BOUNDARY_ORIGINY_optional&
  CENTER_BOUNDARY_ORIGINY () const;

  CENTER_BOUNDARY_ORIGINY_optional&
  CENTER_BOUNDARY_ORIGINY ();

  void
  CENTER_BOUNDARY_ORIGINY (const CENTER_BOUNDARY_ORIGINY_type& x);

  void
  CENTER_BOUNDARY_ORIGINY (const CENTER_BOUNDARY_ORIGINY_optional& x);

  // CENTER_BOUNDARY_ORIGINZ
  //
  typedef ::xml_schema::double_ CENTER_BOUNDARY_ORIGINZ_type;
  typedef ::xsd::cxx::tree::optional< CENTER_BOUNDARY_ORIGINZ_type > CENTER_BOUNDARY_ORIGINZ_optional;
  typedef ::xsd::cxx::tree::traits< CENTER_BOUNDARY_ORIGINZ_type, char, ::xsd::cxx::tree::schema_type::double_ > CENTER_BOUNDARY_ORIGINZ_traits;

  const CENTER_BOUNDARY_ORIGINZ_optional&
  CENTER_BOUNDARY_ORIGINZ () const;

  CENTER_BOUNDARY_ORIGINZ_optional&
  CENTER_BOUNDARY_ORIGINZ ();

  void
  CENTER_BOUNDARY_ORIGINZ (const CENTER_BOUNDARY_ORIGINZ_type& x);

  void
  CENTER_BOUNDARY_ORIGINZ (const CENTER_BOUNDARY_ORIGINZ_optional& x);

  // EXTENT_WIDTH
  //
  typedef ::xml_schema::double_ EXTENT_WIDTH_type;
  typedef ::xsd::cxx::tree::optional< EXTENT_WIDTH_type > EXTENT_WIDTH_optional;
  typedef ::xsd::cxx::tree::traits< EXTENT_WIDTH_type, char, ::xsd::cxx::tree::schema_type::double_ > EXTENT_WIDTH_traits;

  const EXTENT_WIDTH_optional&
  EXTENT_WIDTH () const;

  EXTENT_WIDTH_optional&
  EXTENT_WIDTH ();

  void
  EXTENT_WIDTH (const EXTENT_WIDTH_type& x);

  void
  EXTENT_WIDTH (const EXTENT_WIDTH_optional& x);

  // EXTENT_HEIGHT
  //
  typedef ::xml_schema::double_ EXTENT_HEIGHT_type;
  typedef ::xsd::cxx::tree::optional< EXTENT_HEIGHT_type > EXTENT_HEIGHT_optional;
  typedef ::xsd::cxx::tree::traits< EXTENT_HEIGHT_type, char, ::xsd::cxx::tree::schema_type::double_ > EXTENT_HEIGHT_traits;

  const EXTENT_HEIGHT_optional&
  EXTENT_HEIGHT () const;

  EXTENT_HEIGHT_optional&
  EXTENT_HEIGHT ();

  void
  EXTENT_HEIGHT (const EXTENT_HEIGHT_type& x);

  void
  EXTENT_HEIGHT (const EXTENT_HEIGHT_optional& x);

  // EXTENT_DEPTH
  //
  typedef ::xml_schema::double_ EXTENT_DEPTH_type;
  typedef ::xsd::cxx::tree::optional< EXTENT_DEPTH_type > EXTENT_DEPTH_optional;
  typedef ::xsd::cxx::tree::traits< EXTENT_DEPTH_type, char, ::xsd::cxx::tree::schema_type::double_ > EXTENT_DEPTH_traits;

  const EXTENT_DEPTH_optional&
  EXTENT_DEPTH () const;

  EXTENT_DEPTH_optional&
  EXTENT_DEPTH ();

  void
  EXTENT_DEPTH (const EXTENT_DEPTH_type& x);

  void
  EXTENT_DEPTH (const EXTENT_DEPTH_optional& x);

  // Constructors.
  //
  Boundary (const typeLEFT_type&,
            const typeRIGHT_type&,
            const typeTOP_type&,
            const typeBOTTOM_type&,
            const typeFRONT_type&,
            const typeBACK_type&);

  Boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Boundary (const Boundary& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Boundary*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Boundary&
  operator= (const Boundary& x);

  virtual 
  ~Boundary ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< typeLEFT_type > typeLEFT_;
  ::xsd::cxx::tree::one< typeRIGHT_type > typeRIGHT_;
  ::xsd::cxx::tree::one< typeTOP_type > typeTOP_;
  ::xsd::cxx::tree::one< typeBOTTOM_type > typeBOTTOM_;
  ::xsd::cxx::tree::one< typeFRONT_type > typeFRONT_;
  ::xsd::cxx::tree::one< typeBACK_type > typeBACK_;
  CENTER_BOUNDARY_ORIGINX_optional CENTER_BOUNDARY_ORIGINX_;
  CENTER_BOUNDARY_ORIGINY_optional CENTER_BOUNDARY_ORIGINY_;
  CENTER_BOUNDARY_ORIGINZ_optional CENTER_BOUNDARY_ORIGINZ_;
  EXTENT_WIDTH_optional EXTENT_WIDTH_;
  EXTENT_HEIGHT_optional EXTENT_HEIGHT_;
  EXTENT_DEPTH_optional EXTENT_DEPTH_;
};

class simulation: public ::xml_schema::type
{
  public:
  // output
  //
  typedef ::output output_type;
  typedef ::xsd::cxx::tree::traits< output_type, char > output_traits;

  const output_type&
  output () const;

  output_type&
  output ();

  void
  output (const output_type& x);

  void
  output (::std::auto_ptr< output_type > p);

  // parameters
  //
  typedef ::parameters parameters_type;
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  const parameters_type&
  parameters () const;

  parameters_type&
  parameters ();

  void
  parameters (const parameters_type& x);

  void
  parameters (::std::auto_ptr< parameters_type > p);

  // Boundary
  //
  typedef ::Boundary Boundary_type;
  typedef ::xsd::cxx::tree::traits< Boundary_type, char > Boundary_traits;

  const Boundary_type&
  Boundary () const;

  Boundary_type&
  Boundary ();

  void
  Boundary (const Boundary_type& x);

  void
  Boundary (::std::auto_ptr< Boundary_type > p);

  // particles
  //
  typedef ::particles particles_type;
  typedef ::xsd::cxx::tree::sequence< particles_type > particles_sequence;
  typedef particles_sequence::iterator particles_iterator;
  typedef particles_sequence::const_iterator particles_const_iterator;
  typedef ::xsd::cxx::tree::traits< particles_type, char > particles_traits;

  const particles_sequence&
  particles () const;

  particles_sequence&
  particles ();

  void
  particles (const particles_sequence& s);

  // Forces
  //
  typedef ::Forces Forces_type;
  typedef ::xsd::cxx::tree::traits< Forces_type, char > Forces_traits;

  const Forces_type&
  Forces () const;

  Forces_type&
  Forces ();

  void
  Forces (const Forces_type& x);

  void
  Forces (::std::auto_ptr< Forces_type > p);

  // Thermostat
  //
  typedef ::Thermostat Thermostat_type;
  typedef ::xsd::cxx::tree::traits< Thermostat_type, char > Thermostat_traits;

  const Thermostat_type&
  Thermostat () const;

  Thermostat_type&
  Thermostat ();

  void
  Thermostat (const Thermostat_type& x);

  void
  Thermostat (::std::auto_ptr< Thermostat_type > p);

  // cuboids
  //
  typedef ::cuboids cuboids_type;
  typedef ::xsd::cxx::tree::sequence< cuboids_type > cuboids_sequence;
  typedef cuboids_sequence::iterator cuboids_iterator;
  typedef cuboids_sequence::const_iterator cuboids_const_iterator;
  typedef ::xsd::cxx::tree::traits< cuboids_type, char > cuboids_traits;

  const cuboids_sequence&
  cuboids () const;

  cuboids_sequence&
  cuboids ();

  void
  cuboids (const cuboids_sequence& s);

  // spheres
  //
  typedef ::spheres spheres_type;
  typedef ::xsd::cxx::tree::sequence< spheres_type > spheres_sequence;
  typedef spheres_sequence::iterator spheres_iterator;
  typedef spheres_sequence::const_iterator spheres_const_iterator;
  typedef ::xsd::cxx::tree::traits< spheres_type, char > spheres_traits;

  const spheres_sequence&
  spheres () const;

  spheres_sequence&
  spheres ();

  void
  spheres (const spheres_sequence& s);

  // Constructors.
  //
  simulation (const output_type&,
              const parameters_type&,
              const Boundary_type&,
              const Forces_type&,
              const Thermostat_type&);

  simulation (::std::auto_ptr< output_type >,
              ::std::auto_ptr< parameters_type >,
              ::std::auto_ptr< Boundary_type >,
              ::std::auto_ptr< Forces_type >,
              ::std::auto_ptr< Thermostat_type >);

  simulation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  simulation (const simulation& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual simulation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  simulation&
  operator= (const simulation& x);

  virtual 
  ~simulation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< output_type > output_;
  ::xsd::cxx::tree::one< parameters_type > parameters_;
  ::xsd::cxx::tree::one< Boundary_type > Boundary_;
  particles_sequence particles_;
  ::xsd::cxx::tree::one< Forces_type > Forces_;
  ::xsd::cxx::tree::one< Thermostat_type > Thermostat_;
  cuboids_sequence cuboids_;
  spheres_sequence spheres_;
};

class output: public ::xml_schema::type
{
  public:
  // baseName
  //
  typedef ::xml_schema::string baseName_type;
  typedef ::xsd::cxx::tree::traits< baseName_type, char > baseName_traits;

  const baseName_type&
  baseName () const;

  baseName_type&
  baseName ();

  void
  baseName (const baseName_type& x);

  void
  baseName (::std::auto_ptr< baseName_type > p);

  // writeFrequency
  //
  typedef ::xml_schema::int_ writeFrequency_type;
  typedef ::xsd::cxx::tree::traits< writeFrequency_type, char > writeFrequency_traits;

  const writeFrequency_type&
  writeFrequency () const;

  writeFrequency_type&
  writeFrequency ();

  void
  writeFrequency (const writeFrequency_type& x);

  // Constructors.
  //
  output (const baseName_type&,
          const writeFrequency_type&);

  output (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  output (const output& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual output*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  output&
  operator= (const output& x);

  virtual 
  ~output ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< baseName_type > baseName_;
  ::xsd::cxx::tree::one< writeFrequency_type > writeFrequency_;
};

class parameters: public ::xml_schema::type
{
  public:
  // tEnd
  //
  typedef ::xml_schema::double_ tEnd_type;
  typedef ::xsd::cxx::tree::traits< tEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > tEnd_traits;

  const tEnd_type&
  tEnd () const;

  tEnd_type&
  tEnd ();

  void
  tEnd (const tEnd_type& x);

  // deltaT
  //
  typedef ::xml_schema::double_ deltaT_type;
  typedef ::xsd::cxx::tree::traits< deltaT_type, char, ::xsd::cxx::tree::schema_type::double_ > deltaT_traits;

  const deltaT_type&
  deltaT () const;

  deltaT_type&
  deltaT ();

  void
  deltaT (const deltaT_type& x);

  // cutoff_radius
  //
  typedef ::xml_schema::double_ cutoff_radius_type;
  typedef ::xsd::cxx::tree::traits< cutoff_radius_type, char, ::xsd::cxx::tree::schema_type::double_ > cutoff_radius_traits;

  const cutoff_radius_type&
  cutoff_radius () const;

  cutoff_radius_type&
  cutoff_radius ();

  void
  cutoff_radius (const cutoff_radius_type& x);

  // gravitational_force
  //
  typedef ::xml_schema::double_ gravitational_force_type;
  typedef ::xsd::cxx::tree::traits< gravitational_force_type, char, ::xsd::cxx::tree::schema_type::double_ > gravitational_force_traits;

  const gravitational_force_type&
  gravitational_force () const;

  gravitational_force_type&
  gravitational_force ();

  void
  gravitational_force (const gravitational_force_type& x);

  // Constructors.
  //
  parameters (const tEnd_type&,
              const deltaT_type&,
              const cutoff_radius_type&,
              const gravitational_force_type&);

  parameters (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  parameters (const parameters& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual parameters*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  parameters&
  operator= (const parameters& x);

  virtual 
  ~parameters ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< tEnd_type > tEnd_;
  ::xsd::cxx::tree::one< deltaT_type > deltaT_;
  ::xsd::cxx::tree::one< cutoff_radius_type > cutoff_radius_;
  ::xsd::cxx::tree::one< gravitational_force_type > gravitational_force_;
};

class particles: public ::xml_schema::type
{
  public:
  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // vel1
  //
  typedef ::xml_schema::double_ vel1_type;
  typedef ::xsd::cxx::tree::traits< vel1_type, char, ::xsd::cxx::tree::schema_type::double_ > vel1_traits;

  const vel1_type&
  vel1 () const;

  vel1_type&
  vel1 ();

  void
  vel1 (const vel1_type& x);

  // vel2
  //
  typedef ::xml_schema::double_ vel2_type;
  typedef ::xsd::cxx::tree::traits< vel2_type, char, ::xsd::cxx::tree::schema_type::double_ > vel2_traits;

  const vel2_type&
  vel2 () const;

  vel2_type&
  vel2 ();

  void
  vel2 (const vel2_type& x);

  // vel3
  //
  typedef ::xml_schema::double_ vel3_type;
  typedef ::xsd::cxx::tree::traits< vel3_type, char, ::xsd::cxx::tree::schema_type::double_ > vel3_traits;

  const vel3_type&
  vel3 () const;

  vel3_type&
  vel3 ();

  void
  vel3 (const vel3_type& x);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // Constructors.
  //
  particles (const x_type&,
             const y_type&,
             const z_type&,
             const vel1_type&,
             const vel2_type&,
             const vel3_type&,
             const mass_type&);

  particles (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  particles (const particles& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual particles*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  particles&
  operator= (const particles& x);

  virtual 
  ~particles ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< vel1_type > vel1_;
  ::xsd::cxx::tree::one< vel2_type > vel2_;
  ::xsd::cxx::tree::one< vel3_type > vel3_;
  ::xsd::cxx::tree::one< mass_type > mass_;
};

class Forces: public ::xml_schema::type
{
  public:
  // Force
  //
  typedef ::Force Force_type;
  typedef ::xsd::cxx::tree::optional< Force_type > Force_optional;
  typedef ::xsd::cxx::tree::traits< Force_type, char > Force_traits;

  const Force_optional&
  Force () const;

  Force_optional&
  Force ();

  void
  Force (const Force_type& x);

  void
  Force (const Force_optional& x);

  void
  Force (::std::auto_ptr< Force_type > p);

  // Constructors.
  //
  Forces ();

  Forces (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  Forces (const Forces& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual Forces*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Forces&
  operator= (const Forces& x);

  virtual 
  ~Forces ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Force_optional Force_;
};

class Thermostat: public ::xml_schema::type
{
  public:
  // n_thermostats
  //
  typedef ::xml_schema::int_ n_thermostats_type;
  typedef ::xsd::cxx::tree::optional< n_thermostats_type > n_thermostats_optional;
  typedef ::xsd::cxx::tree::traits< n_thermostats_type, char > n_thermostats_traits;

  const n_thermostats_optional&
  n_thermostats () const;

  n_thermostats_optional&
  n_thermostats ();

  void
  n_thermostats (const n_thermostats_type& x);

  void
  n_thermostats (const n_thermostats_optional& x);

  // init_T
  //
  typedef ::xml_schema::double_ init_T_type;
  typedef ::xsd::cxx::tree::optional< init_T_type > init_T_optional;
  typedef ::xsd::cxx::tree::traits< init_T_type, char, ::xsd::cxx::tree::schema_type::double_ > init_T_traits;

  const init_T_optional&
  init_T () const;

  init_T_optional&
  init_T ();

  void
  init_T (const init_T_type& x);

  void
  init_T (const init_T_optional& x);

  // target_T
  //
  typedef ::xml_schema::double_ target_T_type;
  typedef ::xsd::cxx::tree::optional< target_T_type > target_T_optional;
  typedef ::xsd::cxx::tree::traits< target_T_type, char, ::xsd::cxx::tree::schema_type::double_ > target_T_traits;

  const target_T_optional&
  target_T () const;

  target_T_optional&
  target_T ();

  void
  target_T (const target_T_type& x);

  void
  target_T (const target_T_optional& x);

  // temp_dT
  //
  typedef ::xml_schema::double_ temp_dT_type;
  typedef ::xsd::cxx::tree::optional< temp_dT_type > temp_dT_optional;
  typedef ::xsd::cxx::tree::traits< temp_dT_type, char, ::xsd::cxx::tree::schema_type::double_ > temp_dT_traits;

  const temp_dT_optional&
  temp_dT () const;

  temp_dT_optional&
  temp_dT ();

  void
  temp_dT (const temp_dT_type& x);

  void
  temp_dT (const temp_dT_optional& x);

  // Constructors.
  //
  Thermostat ();

  Thermostat (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  Thermostat (const Thermostat& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual Thermostat*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Thermostat&
  operator= (const Thermostat& x);

  virtual 
  ~Thermostat ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  n_thermostats_optional n_thermostats_;
  init_T_optional init_T_;
  target_T_optional target_T_;
  temp_dT_optional temp_dT_;
};

class cuboids: public ::xml_schema::type
{
  public:
  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // vel1
  //
  typedef ::xml_schema::double_ vel1_type;
  typedef ::xsd::cxx::tree::traits< vel1_type, char, ::xsd::cxx::tree::schema_type::double_ > vel1_traits;

  const vel1_type&
  vel1 () const;

  vel1_type&
  vel1 ();

  void
  vel1 (const vel1_type& x);

  // vel2
  //
  typedef ::xml_schema::double_ vel2_type;
  typedef ::xsd::cxx::tree::traits< vel2_type, char, ::xsd::cxx::tree::schema_type::double_ > vel2_traits;

  const vel2_type&
  vel2 () const;

  vel2_type&
  vel2 ();

  void
  vel2 (const vel2_type& x);

  // vel3
  //
  typedef ::xml_schema::double_ vel3_type;
  typedef ::xsd::cxx::tree::traits< vel3_type, char, ::xsd::cxx::tree::schema_type::double_ > vel3_traits;

  const vel3_type&
  vel3 () const;

  vel3_type&
  vel3 ();

  void
  vel3 (const vel3_type& x);

  // numPartX
  //
  typedef ::xml_schema::unsigned_int numPartX_type;
  typedef ::xsd::cxx::tree::traits< numPartX_type, char > numPartX_traits;

  const numPartX_type&
  numPartX () const;

  numPartX_type&
  numPartX ();

  void
  numPartX (const numPartX_type& x);

  // numPartY
  //
  typedef ::xml_schema::unsigned_int numPartY_type;
  typedef ::xsd::cxx::tree::traits< numPartY_type, char > numPartY_traits;

  const numPartY_type&
  numPartY () const;

  numPartY_type&
  numPartY ();

  void
  numPartY (const numPartY_type& x);

  // numPartZ
  //
  typedef ::xml_schema::unsigned_int numPartZ_type;
  typedef ::xsd::cxx::tree::traits< numPartZ_type, char > numPartZ_traits;

  const numPartZ_type&
  numPartZ () const;

  numPartZ_type&
  numPartZ ();

  void
  numPartZ (const numPartZ_type& x);

  // thermal_v
  //
  typedef ::xml_schema::double_ thermal_v_type;
  typedef ::xsd::cxx::tree::traits< thermal_v_type, char, ::xsd::cxx::tree::schema_type::double_ > thermal_v_traits;

  const thermal_v_type&
  thermal_v () const;

  thermal_v_type&
  thermal_v ();

  void
  thermal_v (const thermal_v_type& x);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // dimension
  //
  typedef ::DimensionT dimension_type;
  typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

  const dimension_type&
  dimension () const;

  dimension_type&
  dimension ();

  void
  dimension (const dimension_type& x);

  void
  dimension (::std::auto_ptr< dimension_type > p);

  // type
  //
  typedef ::xml_schema::int_ type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  // Constructors.
  //
  cuboids (const x_type&,
           const y_type&,
           const z_type&,
           const vel1_type&,
           const vel2_type&,
           const vel3_type&,
           const numPartX_type&,
           const numPartY_type&,
           const numPartZ_type&,
           const thermal_v_type&,
           const width_type&,
           const mass_type&,
           const dimension_type&);

  cuboids (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  cuboids (const cuboids& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual cuboids*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  cuboids&
  operator= (const cuboids& x);

  virtual 
  ~cuboids ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< vel1_type > vel1_;
  ::xsd::cxx::tree::one< vel2_type > vel2_;
  ::xsd::cxx::tree::one< vel3_type > vel3_;
  ::xsd::cxx::tree::one< numPartX_type > numPartX_;
  ::xsd::cxx::tree::one< numPartY_type > numPartY_;
  ::xsd::cxx::tree::one< numPartZ_type > numPartZ_;
  ::xsd::cxx::tree::one< thermal_v_type > thermal_v_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< dimension_type > dimension_;
  type_optional type_;
};

class spheres: public ::xml_schema::type
{
  public:
  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // vel1
  //
  typedef ::xml_schema::double_ vel1_type;
  typedef ::xsd::cxx::tree::traits< vel1_type, char, ::xsd::cxx::tree::schema_type::double_ > vel1_traits;

  const vel1_type&
  vel1 () const;

  vel1_type&
  vel1 ();

  void
  vel1 (const vel1_type& x);

  // vel2
  //
  typedef ::xml_schema::double_ vel2_type;
  typedef ::xsd::cxx::tree::traits< vel2_type, char, ::xsd::cxx::tree::schema_type::double_ > vel2_traits;

  const vel2_type&
  vel2 () const;

  vel2_type&
  vel2 ();

  void
  vel2 (const vel2_type& x);

  // vel3
  //
  typedef ::xml_schema::double_ vel3_type;
  typedef ::xsd::cxx::tree::traits< vel3_type, char, ::xsd::cxx::tree::schema_type::double_ > vel3_traits;

  const vel3_type&
  vel3 () const;

  vel3_type&
  vel3 ();

  void
  vel3 (const vel3_type& x);

  // thermal_v
  //
  typedef ::xml_schema::double_ thermal_v_type;
  typedef ::xsd::cxx::tree::traits< thermal_v_type, char, ::xsd::cxx::tree::schema_type::double_ > thermal_v_traits;

  const thermal_v_type&
  thermal_v () const;

  thermal_v_type&
  thermal_v ();

  void
  thermal_v (const thermal_v_type& x);

  // radius
  //
  typedef ::xml_schema::int_ radius_type;
  typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

  const radius_type&
  radius () const;

  radius_type&
  radius ();

  void
  radius (const radius_type& x);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  // mass
  //
  typedef ::xml_schema::double_ mass_type;
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  const mass_type&
  mass () const;

  mass_type&
  mass ();

  void
  mass (const mass_type& x);

  // dimension
  //
  typedef ::DimensionT dimension_type;
  typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

  const dimension_type&
  dimension () const;

  dimension_type&
  dimension ();

  void
  dimension (const dimension_type& x);

  void
  dimension (::std::auto_ptr< dimension_type > p);

  // type
  //
  typedef ::xml_schema::int_ type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  // Constructors.
  //
  spheres (const x_type&,
           const y_type&,
           const z_type&,
           const vel1_type&,
           const vel2_type&,
           const vel3_type&,
           const thermal_v_type&,
           const radius_type&,
           const width_type&,
           const mass_type&,
           const dimension_type&);

  spheres (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  spheres (const spheres& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual spheres*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  spheres&
  operator= (const spheres& x);

  virtual 
  ~spheres ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< vel1_type > vel1_;
  ::xsd::cxx::tree::one< vel2_type > vel2_;
  ::xsd::cxx::tree::one< vel3_type > vel3_;
  ::xsd::cxx::tree::one< thermal_v_type > thermal_v_;
  ::xsd::cxx::tree::one< radius_type > radius_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< dimension_type > dimension_;
  type_optional type_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const DimensionT&);

void
operator<< (::xercesc::DOMAttr&, const DimensionT&);

void
operator<< (::xml_schema::list_stream&,
            const DimensionT&);

void
operator<< (::xercesc::DOMElement&, const ForceType&);

void
operator<< (::xercesc::DOMAttr&, const ForceType&);

void
operator<< (::xml_schema::list_stream&,
            const ForceType&);

void
operator<< (::xercesc::DOMElement&, const Force&);

void
operator<< (::xercesc::DOMElement&, const BoundaryType&);

void
operator<< (::xercesc::DOMAttr&, const BoundaryType&);

void
operator<< (::xml_schema::list_stream&,
            const BoundaryType&);

void
operator<< (::xercesc::DOMElement&, const Boundary&);

// Serialize to std::ostream.
//

void
simulation_ (::std::ostream& os,
             const ::simulation& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::std::ostream& os,
             const ::simulation& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::std::ostream& os,
             const ::simulation& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
simulation_ (::xercesc::XMLFormatTarget& ft,
             const ::simulation& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::xercesc::XMLFormatTarget& ft,
             const ::simulation& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

void
simulation_ (::xercesc::XMLFormatTarget& ft,
             const ::simulation& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
simulation_ (::xercesc::DOMDocument& d,
             const ::simulation& x,
             ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
simulation_ (const ::simulation& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const simulation&);

void
operator<< (::xercesc::DOMElement&, const output&);

void
operator<< (::xercesc::DOMElement&, const parameters&);

void
operator<< (::xercesc::DOMElement&, const particles&);

void
operator<< (::xercesc::DOMElement&, const Forces&);

void
operator<< (::xercesc::DOMElement&, const Thermostat&);

void
operator<< (::xercesc::DOMElement&, const cuboids&);

void
operator<< (::xercesc::DOMElement&, const spheres&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MOL_SIM_SCHEMA_HXX
