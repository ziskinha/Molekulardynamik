// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "molSimSchema.hxx"

// DimensionT
// 

DimensionT::
DimensionT (::xml_schema::int_ v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v)
{
}

DimensionT::
DimensionT (const DimensionT& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (v, f, c)
{
}


// ForceType
// 

ForceType::
ForceType (value v)
: ::xml_schema::string (_xsd_ForceType_literals_[v])
{
}

ForceType::
ForceType (const char* v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ForceType::
ForceType (const ForceType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ForceType& ForceType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ForceType_literals_[v]);

  return *this;
}


// Force
// 

const Force::type_type& Force::
type () const
{
  return this->type_.get ();
}

Force::type_type& Force::
type ()
{
  return this->type_.get ();
}

void Force::
type (const type_type& x)
{
  this->type_.set (x);
}

void Force::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const Force::arg1_optional& Force::
arg1 () const
{
  return this->arg1_;
}

Force::arg1_optional& Force::
arg1 ()
{
  return this->arg1_;
}

void Force::
arg1 (const arg1_type& x)
{
  this->arg1_.set (x);
}

void Force::
arg1 (const arg1_optional& x)
{
  this->arg1_ = x;
}

const Force::arg2_optional& Force::
arg2 () const
{
  return this->arg2_;
}

Force::arg2_optional& Force::
arg2 ()
{
  return this->arg2_;
}

void Force::
arg2 (const arg2_type& x)
{
  this->arg2_.set (x);
}

void Force::
arg2 (const arg2_optional& x)
{
  this->arg2_ = x;
}


// BoundaryType
// 

BoundaryType::
BoundaryType (value v)
: ::xml_schema::string (_xsd_BoundaryType_literals_[v])
{
}

BoundaryType::
BoundaryType (const char* v)
: ::xml_schema::string (v)
{
}

BoundaryType::
BoundaryType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

BoundaryType::
BoundaryType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

BoundaryType::
BoundaryType (const BoundaryType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

BoundaryType& BoundaryType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_BoundaryType_literals_[v]);

  return *this;
}


// Boundary
// 

const Boundary::typeLEFT_type& Boundary::
typeLEFT () const
{
  return this->typeLEFT_.get ();
}

Boundary::typeLEFT_type& Boundary::
typeLEFT ()
{
  return this->typeLEFT_.get ();
}

void Boundary::
typeLEFT (const typeLEFT_type& x)
{
  this->typeLEFT_.set (x);
}

void Boundary::
typeLEFT (::std::auto_ptr< typeLEFT_type > x)
{
  this->typeLEFT_.set (x);
}

const Boundary::typeRIGHT_type& Boundary::
typeRIGHT () const
{
  return this->typeRIGHT_.get ();
}

Boundary::typeRIGHT_type& Boundary::
typeRIGHT ()
{
  return this->typeRIGHT_.get ();
}

void Boundary::
typeRIGHT (const typeRIGHT_type& x)
{
  this->typeRIGHT_.set (x);
}

void Boundary::
typeRIGHT (::std::auto_ptr< typeRIGHT_type > x)
{
  this->typeRIGHT_.set (x);
}

const Boundary::typeTOP_type& Boundary::
typeTOP () const
{
  return this->typeTOP_.get ();
}

Boundary::typeTOP_type& Boundary::
typeTOP ()
{
  return this->typeTOP_.get ();
}

void Boundary::
typeTOP (const typeTOP_type& x)
{
  this->typeTOP_.set (x);
}

void Boundary::
typeTOP (::std::auto_ptr< typeTOP_type > x)
{
  this->typeTOP_.set (x);
}

const Boundary::typeBOTTOM_type& Boundary::
typeBOTTOM () const
{
  return this->typeBOTTOM_.get ();
}

Boundary::typeBOTTOM_type& Boundary::
typeBOTTOM ()
{
  return this->typeBOTTOM_.get ();
}

void Boundary::
typeBOTTOM (const typeBOTTOM_type& x)
{
  this->typeBOTTOM_.set (x);
}

void Boundary::
typeBOTTOM (::std::auto_ptr< typeBOTTOM_type > x)
{
  this->typeBOTTOM_.set (x);
}

const Boundary::typeFRONT_type& Boundary::
typeFRONT () const
{
  return this->typeFRONT_.get ();
}

Boundary::typeFRONT_type& Boundary::
typeFRONT ()
{
  return this->typeFRONT_.get ();
}

void Boundary::
typeFRONT (const typeFRONT_type& x)
{
  this->typeFRONT_.set (x);
}

void Boundary::
typeFRONT (::std::auto_ptr< typeFRONT_type > x)
{
  this->typeFRONT_.set (x);
}

const Boundary::typeBACK_type& Boundary::
typeBACK () const
{
  return this->typeBACK_.get ();
}

Boundary::typeBACK_type& Boundary::
typeBACK ()
{
  return this->typeBACK_.get ();
}

void Boundary::
typeBACK (const typeBACK_type& x)
{
  this->typeBACK_.set (x);
}

void Boundary::
typeBACK (::std::auto_ptr< typeBACK_type > x)
{
  this->typeBACK_.set (x);
}

const Boundary::CENTER_BOUNDARY_ORIGINX_optional& Boundary::
CENTER_BOUNDARY_ORIGINX () const
{
  return this->CENTER_BOUNDARY_ORIGINX_;
}

Boundary::CENTER_BOUNDARY_ORIGINX_optional& Boundary::
CENTER_BOUNDARY_ORIGINX ()
{
  return this->CENTER_BOUNDARY_ORIGINX_;
}

void Boundary::
CENTER_BOUNDARY_ORIGINX (const CENTER_BOUNDARY_ORIGINX_type& x)
{
  this->CENTER_BOUNDARY_ORIGINX_.set (x);
}

void Boundary::
CENTER_BOUNDARY_ORIGINX (const CENTER_BOUNDARY_ORIGINX_optional& x)
{
  this->CENTER_BOUNDARY_ORIGINX_ = x;
}

const Boundary::CENTER_BOUNDARY_ORIGINY_optional& Boundary::
CENTER_BOUNDARY_ORIGINY () const
{
  return this->CENTER_BOUNDARY_ORIGINY_;
}

Boundary::CENTER_BOUNDARY_ORIGINY_optional& Boundary::
CENTER_BOUNDARY_ORIGINY ()
{
  return this->CENTER_BOUNDARY_ORIGINY_;
}

void Boundary::
CENTER_BOUNDARY_ORIGINY (const CENTER_BOUNDARY_ORIGINY_type& x)
{
  this->CENTER_BOUNDARY_ORIGINY_.set (x);
}

void Boundary::
CENTER_BOUNDARY_ORIGINY (const CENTER_BOUNDARY_ORIGINY_optional& x)
{
  this->CENTER_BOUNDARY_ORIGINY_ = x;
}

const Boundary::CENTER_BOUNDARY_ORIGINZ_optional& Boundary::
CENTER_BOUNDARY_ORIGINZ () const
{
  return this->CENTER_BOUNDARY_ORIGINZ_;
}

Boundary::CENTER_BOUNDARY_ORIGINZ_optional& Boundary::
CENTER_BOUNDARY_ORIGINZ ()
{
  return this->CENTER_BOUNDARY_ORIGINZ_;
}

void Boundary::
CENTER_BOUNDARY_ORIGINZ (const CENTER_BOUNDARY_ORIGINZ_type& x)
{
  this->CENTER_BOUNDARY_ORIGINZ_.set (x);
}

void Boundary::
CENTER_BOUNDARY_ORIGINZ (const CENTER_BOUNDARY_ORIGINZ_optional& x)
{
  this->CENTER_BOUNDARY_ORIGINZ_ = x;
}

const Boundary::EXTENT_WIDTH_optional& Boundary::
EXTENT_WIDTH () const
{
  return this->EXTENT_WIDTH_;
}

Boundary::EXTENT_WIDTH_optional& Boundary::
EXTENT_WIDTH ()
{
  return this->EXTENT_WIDTH_;
}

void Boundary::
EXTENT_WIDTH (const EXTENT_WIDTH_type& x)
{
  this->EXTENT_WIDTH_.set (x);
}

void Boundary::
EXTENT_WIDTH (const EXTENT_WIDTH_optional& x)
{
  this->EXTENT_WIDTH_ = x;
}

const Boundary::EXTENT_HEIGHT_optional& Boundary::
EXTENT_HEIGHT () const
{
  return this->EXTENT_HEIGHT_;
}

Boundary::EXTENT_HEIGHT_optional& Boundary::
EXTENT_HEIGHT ()
{
  return this->EXTENT_HEIGHT_;
}

void Boundary::
EXTENT_HEIGHT (const EXTENT_HEIGHT_type& x)
{
  this->EXTENT_HEIGHT_.set (x);
}

void Boundary::
EXTENT_HEIGHT (const EXTENT_HEIGHT_optional& x)
{
  this->EXTENT_HEIGHT_ = x;
}

const Boundary::EXTENT_DEPTH_optional& Boundary::
EXTENT_DEPTH () const
{
  return this->EXTENT_DEPTH_;
}

Boundary::EXTENT_DEPTH_optional& Boundary::
EXTENT_DEPTH ()
{
  return this->EXTENT_DEPTH_;
}

void Boundary::
EXTENT_DEPTH (const EXTENT_DEPTH_type& x)
{
  this->EXTENT_DEPTH_.set (x);
}

void Boundary::
EXTENT_DEPTH (const EXTENT_DEPTH_optional& x)
{
  this->EXTENT_DEPTH_ = x;
}


// simulation
// 

const simulation::output_type& simulation::
output () const
{
  return this->output_.get ();
}

simulation::output_type& simulation::
output ()
{
  return this->output_.get ();
}

void simulation::
output (const output_type& x)
{
  this->output_.set (x);
}

void simulation::
output (::std::auto_ptr< output_type > x)
{
  this->output_.set (x);
}

const simulation::parameters_type& simulation::
parameters () const
{
  return this->parameters_.get ();
}

simulation::parameters_type& simulation::
parameters ()
{
  return this->parameters_.get ();
}

void simulation::
parameters (const parameters_type& x)
{
  this->parameters_.set (x);
}

void simulation::
parameters (::std::auto_ptr< parameters_type > x)
{
  this->parameters_.set (x);
}

const simulation::Boundary_type& simulation::
Boundary () const
{
  return this->Boundary_.get ();
}

simulation::Boundary_type& simulation::
Boundary ()
{
  return this->Boundary_.get ();
}

void simulation::
Boundary (const Boundary_type& x)
{
  this->Boundary_.set (x);
}

void simulation::
Boundary (::std::auto_ptr< Boundary_type > x)
{
  this->Boundary_.set (x);
}

const simulation::particles_sequence& simulation::
particles () const
{
  return this->particles_;
}

simulation::particles_sequence& simulation::
particles ()
{
  return this->particles_;
}

void simulation::
particles (const particles_sequence& s)
{
  this->particles_ = s;
}

const simulation::Forces_type& simulation::
Forces () const
{
  return this->Forces_.get ();
}

simulation::Forces_type& simulation::
Forces ()
{
  return this->Forces_.get ();
}

void simulation::
Forces (const Forces_type& x)
{
  this->Forces_.set (x);
}

void simulation::
Forces (::std::auto_ptr< Forces_type > x)
{
  this->Forces_.set (x);
}

const simulation::cuboids_sequence& simulation::
cuboids () const
{
  return this->cuboids_;
}

simulation::cuboids_sequence& simulation::
cuboids ()
{
  return this->cuboids_;
}

void simulation::
cuboids (const cuboids_sequence& s)
{
  this->cuboids_ = s;
}

const simulation::discs_sequence& simulation::
discs () const
{
  return this->discs_;
}

simulation::discs_sequence& simulation::
discs ()
{
  return this->discs_;
}

void simulation::
discs (const discs_sequence& s)
{
  this->discs_ = s;
}


// output
// 

const output::baseName_type& output::
baseName () const
{
  return this->baseName_.get ();
}

output::baseName_type& output::
baseName ()
{
  return this->baseName_.get ();
}

void output::
baseName (const baseName_type& x)
{
  this->baseName_.set (x);
}

void output::
baseName (::std::auto_ptr< baseName_type > x)
{
  this->baseName_.set (x);
}

const output::writeFrequency_type& output::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

output::writeFrequency_type& output::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void output::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}


// parameters
// 

const parameters::tEnd_type& parameters::
tEnd () const
{
  return this->tEnd_.get ();
}

parameters::tEnd_type& parameters::
tEnd ()
{
  return this->tEnd_.get ();
}

void parameters::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const parameters::deltaT_type& parameters::
deltaT () const
{
  return this->deltaT_.get ();
}

parameters::deltaT_type& parameters::
deltaT ()
{
  return this->deltaT_.get ();
}

void parameters::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

const parameters::cutoff_radius_type& parameters::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

parameters::cutoff_radius_type& parameters::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void parameters::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}


// particles
// 

const particles::x_type& particles::
x () const
{
  return this->x_.get ();
}

particles::x_type& particles::
x ()
{
  return this->x_.get ();
}

void particles::
x (const x_type& x)
{
  this->x_.set (x);
}

const particles::y_type& particles::
y () const
{
  return this->y_.get ();
}

particles::y_type& particles::
y ()
{
  return this->y_.get ();
}

void particles::
y (const y_type& x)
{
  this->y_.set (x);
}

const particles::z_type& particles::
z () const
{
  return this->z_.get ();
}

particles::z_type& particles::
z ()
{
  return this->z_.get ();
}

void particles::
z (const z_type& x)
{
  this->z_.set (x);
}

const particles::vel1_type& particles::
vel1 () const
{
  return this->vel1_.get ();
}

particles::vel1_type& particles::
vel1 ()
{
  return this->vel1_.get ();
}

void particles::
vel1 (const vel1_type& x)
{
  this->vel1_.set (x);
}

const particles::vel2_type& particles::
vel2 () const
{
  return this->vel2_.get ();
}

particles::vel2_type& particles::
vel2 ()
{
  return this->vel2_.get ();
}

void particles::
vel2 (const vel2_type& x)
{
  this->vel2_.set (x);
}

const particles::vel3_type& particles::
vel3 () const
{
  return this->vel3_.get ();
}

particles::vel3_type& particles::
vel3 ()
{
  return this->vel3_.get ();
}

void particles::
vel3 (const vel3_type& x)
{
  this->vel3_.set (x);
}

const particles::mass_type& particles::
mass () const
{
  return this->mass_.get ();
}

particles::mass_type& particles::
mass ()
{
  return this->mass_.get ();
}

void particles::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


// Forces
// 

const Forces::Force_optional& Forces::
Force () const
{
  return this->Force_;
}

Forces::Force_optional& Forces::
Force ()
{
  return this->Force_;
}

void Forces::
Force (const Force_type& x)
{
  this->Force_.set (x);
}

void Forces::
Force (const Force_optional& x)
{
  this->Force_ = x;
}

void Forces::
Force (::std::auto_ptr< Force_type > x)
{
  this->Force_.set (x);
}


// cuboids
// 

const cuboids::x_type& cuboids::
x () const
{
  return this->x_.get ();
}

cuboids::x_type& cuboids::
x ()
{
  return this->x_.get ();
}

void cuboids::
x (const x_type& x)
{
  this->x_.set (x);
}

const cuboids::y_type& cuboids::
y () const
{
  return this->y_.get ();
}

cuboids::y_type& cuboids::
y ()
{
  return this->y_.get ();
}

void cuboids::
y (const y_type& x)
{
  this->y_.set (x);
}

const cuboids::z_type& cuboids::
z () const
{
  return this->z_.get ();
}

cuboids::z_type& cuboids::
z ()
{
  return this->z_.get ();
}

void cuboids::
z (const z_type& x)
{
  this->z_.set (x);
}

const cuboids::vel1_type& cuboids::
vel1 () const
{
  return this->vel1_.get ();
}

cuboids::vel1_type& cuboids::
vel1 ()
{
  return this->vel1_.get ();
}

void cuboids::
vel1 (const vel1_type& x)
{
  this->vel1_.set (x);
}

const cuboids::vel2_type& cuboids::
vel2 () const
{
  return this->vel2_.get ();
}

cuboids::vel2_type& cuboids::
vel2 ()
{
  return this->vel2_.get ();
}

void cuboids::
vel2 (const vel2_type& x)
{
  this->vel2_.set (x);
}

const cuboids::vel3_type& cuboids::
vel3 () const
{
  return this->vel3_.get ();
}

cuboids::vel3_type& cuboids::
vel3 ()
{
  return this->vel3_.get ();
}

void cuboids::
vel3 (const vel3_type& x)
{
  this->vel3_.set (x);
}

const cuboids::numPartX_type& cuboids::
numPartX () const
{
  return this->numPartX_.get ();
}

cuboids::numPartX_type& cuboids::
numPartX ()
{
  return this->numPartX_.get ();
}

void cuboids::
numPartX (const numPartX_type& x)
{
  this->numPartX_.set (x);
}

const cuboids::numPartY_type& cuboids::
numPartY () const
{
  return this->numPartY_.get ();
}

cuboids::numPartY_type& cuboids::
numPartY ()
{
  return this->numPartY_.get ();
}

void cuboids::
numPartY (const numPartY_type& x)
{
  this->numPartY_.set (x);
}

const cuboids::numPartZ_type& cuboids::
numPartZ () const
{
  return this->numPartZ_.get ();
}

cuboids::numPartZ_type& cuboids::
numPartZ ()
{
  return this->numPartZ_.get ();
}

void cuboids::
numPartZ (const numPartZ_type& x)
{
  this->numPartZ_.set (x);
}

const cuboids::thermal_v_type& cuboids::
thermal_v () const
{
  return this->thermal_v_.get ();
}

cuboids::thermal_v_type& cuboids::
thermal_v ()
{
  return this->thermal_v_.get ();
}

void cuboids::
thermal_v (const thermal_v_type& x)
{
  this->thermal_v_.set (x);
}

const cuboids::width_type& cuboids::
width () const
{
  return this->width_.get ();
}

cuboids::width_type& cuboids::
width ()
{
  return this->width_.get ();
}

void cuboids::
width (const width_type& x)
{
  this->width_.set (x);
}

const cuboids::mass_type& cuboids::
mass () const
{
  return this->mass_.get ();
}

cuboids::mass_type& cuboids::
mass ()
{
  return this->mass_.get ();
}

void cuboids::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboids::dimension_type& cuboids::
dimension () const
{
  return this->dimension_.get ();
}

cuboids::dimension_type& cuboids::
dimension ()
{
  return this->dimension_.get ();
}

void cuboids::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

void cuboids::
dimension (::std::auto_ptr< dimension_type > x)
{
  this->dimension_.set (x);
}

const cuboids::type_optional& cuboids::
type () const
{
  return this->type_;
}

cuboids::type_optional& cuboids::
type ()
{
  return this->type_;
}

void cuboids::
type (const type_type& x)
{
  this->type_.set (x);
}

void cuboids::
type (const type_optional& x)
{
  this->type_ = x;
}


// discs
// 

const discs::x_type& discs::
x () const
{
  return this->x_.get ();
}

discs::x_type& discs::
x ()
{
  return this->x_.get ();
}

void discs::
x (const x_type& x)
{
  this->x_.set (x);
}

const discs::y_type& discs::
y () const
{
  return this->y_.get ();
}

discs::y_type& discs::
y ()
{
  return this->y_.get ();
}

void discs::
y (const y_type& x)
{
  this->y_.set (x);
}

const discs::z_type& discs::
z () const
{
  return this->z_.get ();
}

discs::z_type& discs::
z ()
{
  return this->z_.get ();
}

void discs::
z (const z_type& x)
{
  this->z_.set (x);
}

const discs::vel1_type& discs::
vel1 () const
{
  return this->vel1_.get ();
}

discs::vel1_type& discs::
vel1 ()
{
  return this->vel1_.get ();
}

void discs::
vel1 (const vel1_type& x)
{
  this->vel1_.set (x);
}

const discs::vel2_type& discs::
vel2 () const
{
  return this->vel2_.get ();
}

discs::vel2_type& discs::
vel2 ()
{
  return this->vel2_.get ();
}

void discs::
vel2 (const vel2_type& x)
{
  this->vel2_.set (x);
}

const discs::vel3_type& discs::
vel3 () const
{
  return this->vel3_.get ();
}

discs::vel3_type& discs::
vel3 ()
{
  return this->vel3_.get ();
}

void discs::
vel3 (const vel3_type& x)
{
  this->vel3_.set (x);
}

const discs::distance_h_type& discs::
distance_h () const
{
  return this->distance_h_.get ();
}

discs::distance_h_type& discs::
distance_h ()
{
  return this->distance_h_.get ();
}

void discs::
distance_h (const distance_h_type& x)
{
  this->distance_h_.set (x);
}

const discs::radius_type& discs::
radius () const
{
  return this->radius_.get ();
}

discs::radius_type& discs::
radius ()
{
  return this->radius_.get ();
}

void discs::
radius (const radius_type& x)
{
  this->radius_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// DimensionT
//

DimensionT::
DimensionT (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
{
}

DimensionT::
DimensionT (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
{
}

DimensionT::
DimensionT (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

DimensionT* DimensionT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DimensionT (*this, f, c);
}

// ForceType
//

ForceType::
ForceType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType::
ForceType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ForceType_convert ();
}

ForceType* ForceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceType (*this, f, c);
}

ForceType::value ForceType::
_xsd_ForceType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceType_indexes_,
                    _xsd_ForceType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ForceType_indexes_ + 3 || _xsd_ForceType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceType::
_xsd_ForceType_literals_[3] =
{
  "lennardJones",
  "inverseSquare",
  "HooksLaw"
};

const ForceType::value ForceType::
_xsd_ForceType_indexes_[3] =
{
  ::ForceType::HooksLaw,
  ::ForceType::inverseSquare,
  ::ForceType::lennardJones
};

// Force
//

Force::
Force (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this),
  arg1_ (this),
  arg2_ (this)
{
}

Force::
Force (const Force& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  arg1_ (x.arg1_, f, this),
  arg2_ (x.arg2_, f, this)
{
}

Force::
Force (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  arg1_ (this),
  arg2_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Force::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "arg1" && n.namespace_ ().empty ())
    {
      this->arg1_.set (arg1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "arg2" && n.namespace_ ().empty ())
    {
      this->arg2_.set (arg2_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

Force* Force::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Force (*this, f, c);
}

Force& Force::
operator= (const Force& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->arg1_ = x.arg1_;
    this->arg2_ = x.arg2_;
  }

  return *this;
}

Force::
~Force ()
{
}

// BoundaryType
//

BoundaryType::
BoundaryType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_BoundaryType_convert ();
}

BoundaryType::
BoundaryType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_BoundaryType_convert ();
}

BoundaryType::
BoundaryType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_BoundaryType_convert ();
}

BoundaryType* BoundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoundaryType (*this, f, c);
}

BoundaryType::value BoundaryType::
_xsd_BoundaryType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BoundaryType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_BoundaryType_indexes_,
                    _xsd_BoundaryType_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_BoundaryType_indexes_ + 5 || _xsd_BoundaryType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const BoundaryType::
_xsd_BoundaryType_literals_[5] =
{
  "OUTFLOW",
  "REFLECTIVE_SYMMETRIC",
  "REFLECTIVE_VECTOR",
  "REFLECTIVE_REPULSIVE",
  "PERIODIC"
};

const BoundaryType::value BoundaryType::
_xsd_BoundaryType_indexes_[5] =
{
  ::BoundaryType::OUTFLOW,
  ::BoundaryType::PERIODIC,
  ::BoundaryType::REFLECTIVE_REPULSIVE,
  ::BoundaryType::REFLECTIVE_SYMMETRIC,
  ::BoundaryType::REFLECTIVE_VECTOR
};

// Boundary
//

Boundary::
Boundary (const typeLEFT_type& typeLEFT,
          const typeRIGHT_type& typeRIGHT,
          const typeTOP_type& typeTOP,
          const typeBOTTOM_type& typeBOTTOM,
          const typeFRONT_type& typeFRONT,
          const typeBACK_type& typeBACK)
: ::xml_schema::type (),
  typeLEFT_ (typeLEFT, this),
  typeRIGHT_ (typeRIGHT, this),
  typeTOP_ (typeTOP, this),
  typeBOTTOM_ (typeBOTTOM, this),
  typeFRONT_ (typeFRONT, this),
  typeBACK_ (typeBACK, this),
  CENTER_BOUNDARY_ORIGINX_ (this),
  CENTER_BOUNDARY_ORIGINY_ (this),
  CENTER_BOUNDARY_ORIGINZ_ (this),
  EXTENT_WIDTH_ (this),
  EXTENT_HEIGHT_ (this),
  EXTENT_DEPTH_ (this)
{
}

Boundary::
Boundary (const Boundary& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  typeLEFT_ (x.typeLEFT_, f, this),
  typeRIGHT_ (x.typeRIGHT_, f, this),
  typeTOP_ (x.typeTOP_, f, this),
  typeBOTTOM_ (x.typeBOTTOM_, f, this),
  typeFRONT_ (x.typeFRONT_, f, this),
  typeBACK_ (x.typeBACK_, f, this),
  CENTER_BOUNDARY_ORIGINX_ (x.CENTER_BOUNDARY_ORIGINX_, f, this),
  CENTER_BOUNDARY_ORIGINY_ (x.CENTER_BOUNDARY_ORIGINY_, f, this),
  CENTER_BOUNDARY_ORIGINZ_ (x.CENTER_BOUNDARY_ORIGINZ_, f, this),
  EXTENT_WIDTH_ (x.EXTENT_WIDTH_, f, this),
  EXTENT_HEIGHT_ (x.EXTENT_HEIGHT_, f, this),
  EXTENT_DEPTH_ (x.EXTENT_DEPTH_, f, this)
{
}

Boundary::
Boundary (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  typeLEFT_ (this),
  typeRIGHT_ (this),
  typeTOP_ (this),
  typeBOTTOM_ (this),
  typeFRONT_ (this),
  typeBACK_ (this),
  CENTER_BOUNDARY_ORIGINX_ (this),
  CENTER_BOUNDARY_ORIGINY_ (this),
  CENTER_BOUNDARY_ORIGINZ_ (this),
  EXTENT_WIDTH_ (this),
  EXTENT_HEIGHT_ (this),
  EXTENT_DEPTH_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Boundary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "typeLEFT" && n.namespace_ ().empty ())
    {
      this->typeLEFT_.set (typeLEFT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeRIGHT" && n.namespace_ ().empty ())
    {
      this->typeRIGHT_.set (typeRIGHT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeTOP" && n.namespace_ ().empty ())
    {
      this->typeTOP_.set (typeTOP_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeBOTTOM" && n.namespace_ ().empty ())
    {
      this->typeBOTTOM_.set (typeBOTTOM_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeFRONT" && n.namespace_ ().empty ())
    {
      this->typeFRONT_.set (typeFRONT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typeBACK" && n.namespace_ ().empty ())
    {
      this->typeBACK_.set (typeBACK_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "CENTER_BOUNDARY_ORIGINX" && n.namespace_ ().empty ())
    {
      this->CENTER_BOUNDARY_ORIGINX_.set (CENTER_BOUNDARY_ORIGINX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "CENTER_BOUNDARY_ORIGINY" && n.namespace_ ().empty ())
    {
      this->CENTER_BOUNDARY_ORIGINY_.set (CENTER_BOUNDARY_ORIGINY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "CENTER_BOUNDARY_ORIGINZ" && n.namespace_ ().empty ())
    {
      this->CENTER_BOUNDARY_ORIGINZ_.set (CENTER_BOUNDARY_ORIGINZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EXTENT_WIDTH" && n.namespace_ ().empty ())
    {
      this->EXTENT_WIDTH_.set (EXTENT_WIDTH_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EXTENT_HEIGHT" && n.namespace_ ().empty ())
    {
      this->EXTENT_HEIGHT_.set (EXTENT_HEIGHT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EXTENT_DEPTH" && n.namespace_ ().empty ())
    {
      this->EXTENT_DEPTH_.set (EXTENT_DEPTH_traits::create (i, f, this));
      continue;
    }
  }

  if (!typeLEFT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeLEFT",
      "");
  }

  if (!typeRIGHT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeRIGHT",
      "");
  }

  if (!typeTOP_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeTOP",
      "");
  }

  if (!typeBOTTOM_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeBOTTOM",
      "");
  }

  if (!typeFRONT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeFRONT",
      "");
  }

  if (!typeBACK_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typeBACK",
      "");
  }
}

Boundary* Boundary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Boundary (*this, f, c);
}

Boundary& Boundary::
operator= (const Boundary& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->typeLEFT_ = x.typeLEFT_;
    this->typeRIGHT_ = x.typeRIGHT_;
    this->typeTOP_ = x.typeTOP_;
    this->typeBOTTOM_ = x.typeBOTTOM_;
    this->typeFRONT_ = x.typeFRONT_;
    this->typeBACK_ = x.typeBACK_;
    this->CENTER_BOUNDARY_ORIGINX_ = x.CENTER_BOUNDARY_ORIGINX_;
    this->CENTER_BOUNDARY_ORIGINY_ = x.CENTER_BOUNDARY_ORIGINY_;
    this->CENTER_BOUNDARY_ORIGINZ_ = x.CENTER_BOUNDARY_ORIGINZ_;
    this->EXTENT_WIDTH_ = x.EXTENT_WIDTH_;
    this->EXTENT_HEIGHT_ = x.EXTENT_HEIGHT_;
    this->EXTENT_DEPTH_ = x.EXTENT_DEPTH_;
  }

  return *this;
}

Boundary::
~Boundary ()
{
}

// simulation
//

simulation::
simulation (const output_type& output,
            const parameters_type& parameters,
            const Boundary_type& Boundary,
            const Forces_type& Forces)
: ::xml_schema::type (),
  output_ (output, this),
  parameters_ (parameters, this),
  Boundary_ (Boundary, this),
  particles_ (this),
  Forces_ (Forces, this),
  cuboids_ (this),
  discs_ (this)
{
}

simulation::
simulation (::std::auto_ptr< output_type > output,
            ::std::auto_ptr< parameters_type > parameters,
            ::std::auto_ptr< Boundary_type > Boundary,
            ::std::auto_ptr< Forces_type > Forces)
: ::xml_schema::type (),
  output_ (output, this),
  parameters_ (parameters, this),
  Boundary_ (Boundary, this),
  particles_ (this),
  Forces_ (Forces, this),
  cuboids_ (this),
  discs_ (this)
{
}

simulation::
simulation (const simulation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  output_ (x.output_, f, this),
  parameters_ (x.parameters_, f, this),
  Boundary_ (x.Boundary_, f, this),
  particles_ (x.particles_, f, this),
  Forces_ (x.Forces_, f, this),
  cuboids_ (x.cuboids_, f, this),
  discs_ (x.discs_, f, this)
{
}

simulation::
simulation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  output_ (this),
  parameters_ (this),
  Boundary_ (this),
  particles_ (this),
  Forces_ (this),
  cuboids_ (this),
  discs_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (r);
        continue;
      }
    }

    // parameters
    //
    if (n.name () == "parameters" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parameters_type > r (
        parameters_traits::create (i, f, this));

      if (!parameters_.present ())
      {
        this->parameters_.set (r);
        continue;
      }
    }

    // Boundary
    //
    if (n.name () == "Boundary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Boundary_type > r (
        Boundary_traits::create (i, f, this));

      if (!Boundary_.present ())
      {
        this->Boundary_.set (r);
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      this->particles_.push_back (r);
      continue;
    }

    // Forces
    //
    if (n.name () == "Forces" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Forces_type > r (
        Forces_traits::create (i, f, this));

      if (!Forces_.present ())
      {
        this->Forces_.set (r);
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      this->cuboids_.push_back (r);
      continue;
    }

    // discs
    //
    if (n.name () == "discs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< discs_type > r (
        discs_traits::create (i, f, this));

      this->discs_.push_back (r);
      continue;
    }

    break;
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  if (!parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parameters",
      "");
  }

  if (!Boundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Boundary",
      "");
  }

  if (!Forces_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Forces",
      "");
  }
}

simulation* simulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation (*this, f, c);
}

simulation& simulation::
operator= (const simulation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->output_ = x.output_;
    this->parameters_ = x.parameters_;
    this->Boundary_ = x.Boundary_;
    this->particles_ = x.particles_;
    this->Forces_ = x.Forces_;
    this->cuboids_ = x.cuboids_;
    this->discs_ = x.discs_;
  }

  return *this;
}

simulation::
~simulation ()
{
}

// output
//

output::
output (const baseName_type& baseName,
        const writeFrequency_type& writeFrequency)
: ::xml_schema::type (),
  baseName_ (baseName, this),
  writeFrequency_ (writeFrequency, this)
{
}

output::
output (const output& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseName_ (x.baseName_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this)
{
}

output::
output (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseName_ (this),
  writeFrequency_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void output::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseName
    //
    if (n.name () == "baseName" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< baseName_type > r (
        baseName_traits::create (i, f, this));

      if (!baseName_.present ())
      {
        this->baseName_.set (r);
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!baseName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseName",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }
}

output* output::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output (*this, f, c);
}

output& output::
operator= (const output& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseName_ = x.baseName_;
    this->writeFrequency_ = x.writeFrequency_;
  }

  return *this;
}

output::
~output ()
{
}

// parameters
//

parameters::
parameters (const tEnd_type& tEnd,
            const deltaT_type& deltaT,
            const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  cutoff_radius_ (cutoff_radius, this)
{
}

parameters::
parameters (const parameters& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tEnd_ (x.tEnd_, f, this),
  deltaT_ (x.deltaT_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this)
{
}

parameters::
parameters (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tEnd_ (this),
  deltaT_ (this),
  cutoff_radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tEnd
    //
    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      if (!tEnd_.present ())
      {
        this->tEnd_.set (tEnd_traits::create (i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      if (!deltaT_.present ())
      {
        this->deltaT_.set (deltaT_traits::create (i, f, this));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tEnd",
      "");
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deltaT",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }
}

parameters* parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parameters (*this, f, c);
}

parameters& parameters::
operator= (const parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->tEnd_ = x.tEnd_;
    this->deltaT_ = x.deltaT_;
    this->cutoff_radius_ = x.cutoff_radius_;
  }

  return *this;
}

parameters::
~parameters ()
{
}

// particles
//

particles::
particles (const x_type& x,
           const y_type& y,
           const z_type& z,
           const vel1_type& vel1,
           const vel2_type& vel2,
           const vel3_type& vel3,
           const mass_type& mass)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  vel1_ (vel1, this),
  vel2_ (vel2, this),
  vel3_ (vel3, this),
  mass_ (mass, this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  vel1_ (x.vel1_, f, this),
  vel2_ (x.vel2_, f, this),
  vel3_ (x.vel3_, f, this),
  mass_ (x.mass_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  vel1_ (this),
  vel2_ (this),
  vel3_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // vel1
    //
    if (n.name () == "vel1" && n.namespace_ ().empty ())
    {
      if (!vel1_.present ())
      {
        this->vel1_.set (vel1_traits::create (i, f, this));
        continue;
      }
    }

    // vel2
    //
    if (n.name () == "vel2" && n.namespace_ ().empty ())
    {
      if (!vel2_.present ())
      {
        this->vel2_.set (vel2_traits::create (i, f, this));
        continue;
      }
    }

    // vel3
    //
    if (n.name () == "vel3" && n.namespace_ ().empty ())
    {
      if (!vel3_.present ())
      {
        this->vel3_.set (vel3_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }

  if (!vel1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel1",
      "");
  }

  if (!vel2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel2",
      "");
  }

  if (!vel3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel3",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->vel1_ = x.vel1_;
    this->vel2_ = x.vel2_;
    this->vel3_ = x.vel3_;
    this->mass_ = x.mass_;
  }

  return *this;
}

particles::
~particles ()
{
}

// Forces
//

Forces::
Forces ()
: ::xml_schema::type (),
  Force_ (this)
{
}

Forces::
Forces (const Forces& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Force_ (x.Force_, f, this)
{
}

Forces::
Forces (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Force_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Forces::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Force
    //
    if (n.name () == "Force" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Force_type > r (
        Force_traits::create (i, f, this));

      if (!this->Force_)
      {
        this->Force_.set (r);
        continue;
      }
    }

    break;
  }
}

Forces* Forces::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Forces (*this, f, c);
}

Forces& Forces::
operator= (const Forces& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Force_ = x.Force_;
  }

  return *this;
}

Forces::
~Forces ()
{
}

// cuboids
//

cuboids::
cuboids (const x_type& x,
         const y_type& y,
         const z_type& z,
         const vel1_type& vel1,
         const vel2_type& vel2,
         const vel3_type& vel3,
         const numPartX_type& numPartX,
         const numPartY_type& numPartY,
         const numPartZ_type& numPartZ,
         const thermal_v_type& thermal_v,
         const width_type& width,
         const mass_type& mass,
         const dimension_type& dimension)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  vel1_ (vel1, this),
  vel2_ (vel2, this),
  vel3_ (vel3, this),
  numPartX_ (numPartX, this),
  numPartY_ (numPartY, this),
  numPartZ_ (numPartZ, this),
  thermal_v_ (thermal_v, this),
  width_ (width, this),
  mass_ (mass, this),
  dimension_ (dimension, this),
  type_ (this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  vel1_ (x.vel1_, f, this),
  vel2_ (x.vel2_, f, this),
  vel3_ (x.vel3_, f, this),
  numPartX_ (x.numPartX_, f, this),
  numPartY_ (x.numPartY_, f, this),
  numPartZ_ (x.numPartZ_, f, this),
  thermal_v_ (x.thermal_v_, f, this),
  width_ (x.width_, f, this),
  mass_ (x.mass_, f, this),
  dimension_ (x.dimension_, f, this),
  type_ (x.type_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  vel1_ (this),
  vel2_ (this),
  vel3_ (this),
  numPartX_ (this),
  numPartY_ (this),
  numPartZ_ (this),
  thermal_v_ (this),
  width_ (this),
  mass_ (this),
  dimension_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // vel1
    //
    if (n.name () == "vel1" && n.namespace_ ().empty ())
    {
      if (!vel1_.present ())
      {
        this->vel1_.set (vel1_traits::create (i, f, this));
        continue;
      }
    }

    // vel2
    //
    if (n.name () == "vel2" && n.namespace_ ().empty ())
    {
      if (!vel2_.present ())
      {
        this->vel2_.set (vel2_traits::create (i, f, this));
        continue;
      }
    }

    // vel3
    //
    if (n.name () == "vel3" && n.namespace_ ().empty ())
    {
      if (!vel3_.present ())
      {
        this->vel3_.set (vel3_traits::create (i, f, this));
        continue;
      }
    }

    // numPartX
    //
    if (n.name () == "numPartX" && n.namespace_ ().empty ())
    {
      if (!numPartX_.present ())
      {
        this->numPartX_.set (numPartX_traits::create (i, f, this));
        continue;
      }
    }

    // numPartY
    //
    if (n.name () == "numPartY" && n.namespace_ ().empty ())
    {
      if (!numPartY_.present ())
      {
        this->numPartY_.set (numPartY_traits::create (i, f, this));
        continue;
      }
    }

    // numPartZ
    //
    if (n.name () == "numPartZ" && n.namespace_ ().empty ())
    {
      if (!numPartZ_.present ())
      {
        this->numPartZ_.set (numPartZ_traits::create (i, f, this));
        continue;
      }
    }

    // thermal_v
    //
    if (n.name () == "thermal_v" && n.namespace_ ().empty ())
    {
      if (!thermal_v_.present ())
      {
        this->thermal_v_.set (thermal_v_traits::create (i, f, this));
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      if (!width_.present ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dimension_type > r (
        dimension_traits::create (i, f, this));

      if (!dimension_.present ())
      {
        this->dimension_.set (r);
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!this->type_)
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }

  if (!vel1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel1",
      "");
  }

  if (!vel2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel2",
      "");
  }

  if (!vel3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel3",
      "");
  }

  if (!numPartX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numPartX",
      "");
  }

  if (!numPartY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numPartY",
      "");
  }

  if (!numPartZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numPartZ",
      "");
  }

  if (!thermal_v_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermal_v",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->vel1_ = x.vel1_;
    this->vel2_ = x.vel2_;
    this->vel3_ = x.vel3_;
    this->numPartX_ = x.numPartX_;
    this->numPartY_ = x.numPartY_;
    this->numPartZ_ = x.numPartZ_;
    this->thermal_v_ = x.thermal_v_;
    this->width_ = x.width_;
    this->mass_ = x.mass_;
    this->dimension_ = x.dimension_;
    this->type_ = x.type_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// discs
//

discs::
discs (const x_type& x,
       const y_type& y,
       const z_type& z,
       const vel1_type& vel1,
       const vel2_type& vel2,
       const vel3_type& vel3,
       const distance_h_type& distance_h,
       const radius_type& radius)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  vel1_ (vel1, this),
  vel2_ (vel2, this),
  vel3_ (vel3, this),
  distance_h_ (distance_h, this),
  radius_ (radius, this)
{
}

discs::
discs (const discs& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  vel1_ (x.vel1_, f, this),
  vel2_ (x.vel2_, f, this),
  vel3_ (x.vel3_, f, this),
  distance_h_ (x.distance_h_, f, this),
  radius_ (x.radius_, f, this)
{
}

discs::
discs (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  vel1_ (this),
  vel2_ (this),
  vel3_ (this),
  distance_h_ (this),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void discs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // vel1
    //
    if (n.name () == "vel1" && n.namespace_ ().empty ())
    {
      if (!vel1_.present ())
      {
        this->vel1_.set (vel1_traits::create (i, f, this));
        continue;
      }
    }

    // vel2
    //
    if (n.name () == "vel2" && n.namespace_ ().empty ())
    {
      if (!vel2_.present ())
      {
        this->vel2_.set (vel2_traits::create (i, f, this));
        continue;
      }
    }

    // vel3
    //
    if (n.name () == "vel3" && n.namespace_ ().empty ())
    {
      if (!vel3_.present ())
      {
        this->vel3_.set (vel3_traits::create (i, f, this));
        continue;
      }
    }

    // distance_h
    //
    if (n.name () == "distance_h" && n.namespace_ ().empty ())
    {
      if (!distance_h_.present ())
      {
        this->distance_h_.set (distance_h_traits::create (i, f, this));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }

  if (!vel1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel1",
      "");
  }

  if (!vel2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel2",
      "");
  }

  if (!vel3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel3",
      "");
  }

  if (!distance_h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance_h",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }
}

discs* discs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class discs (*this, f, c);
}

discs& discs::
operator= (const discs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->vel1_ = x.vel1_;
    this->vel2_ = x.vel2_;
    this->vel3_ = x.vel3_;
    this->distance_h_ = x.distance_h_;
    this->radius_ = x.radius_;
  }

  return *this;
}

discs::
~discs ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulation > (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::simulation > (
      ::simulation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::auto_ptr< ::simulation >
simulation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const DimensionT& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const DimensionT& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const DimensionT& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ForceType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Force& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // arg1
  //
  if (i.arg1 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "arg1",
        e));

    a << ::xml_schema::as_double(*i.arg1 ());
  }

  // arg2
  //
  if (i.arg2 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "arg2",
        e));

    a << ::xml_schema::as_double(*i.arg2 ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const BoundaryType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const BoundaryType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const BoundaryType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Boundary& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // typeLEFT
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeLEFT",
        e));

    a << i.typeLEFT ();
  }

  // typeRIGHT
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeRIGHT",
        e));

    a << i.typeRIGHT ();
  }

  // typeTOP
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeTOP",
        e));

    a << i.typeTOP ();
  }

  // typeBOTTOM
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeBOTTOM",
        e));

    a << i.typeBOTTOM ();
  }

  // typeFRONT
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeFRONT",
        e));

    a << i.typeFRONT ();
  }

  // typeBACK
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "typeBACK",
        e));

    a << i.typeBACK ();
  }

  // CENTER_BOUNDARY_ORIGINX
  //
  if (i.CENTER_BOUNDARY_ORIGINX ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "CENTER_BOUNDARY_ORIGINX",
        e));

    a << ::xml_schema::as_double(*i.CENTER_BOUNDARY_ORIGINX ());
  }

  // CENTER_BOUNDARY_ORIGINY
  //
  if (i.CENTER_BOUNDARY_ORIGINY ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "CENTER_BOUNDARY_ORIGINY",
        e));

    a << ::xml_schema::as_double(*i.CENTER_BOUNDARY_ORIGINY ());
  }

  // CENTER_BOUNDARY_ORIGINZ
  //
  if (i.CENTER_BOUNDARY_ORIGINZ ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "CENTER_BOUNDARY_ORIGINZ",
        e));

    a << ::xml_schema::as_double(*i.CENTER_BOUNDARY_ORIGINZ ());
  }

  // EXTENT_WIDTH
  //
  if (i.EXTENT_WIDTH ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EXTENT_WIDTH",
        e));

    a << ::xml_schema::as_double(*i.EXTENT_WIDTH ());
  }

  // EXTENT_HEIGHT
  //
  if (i.EXTENT_HEIGHT ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EXTENT_HEIGHT",
        e));

    a << ::xml_schema::as_double(*i.EXTENT_HEIGHT ());
  }

  // EXTENT_DEPTH
  //
  if (i.EXTENT_DEPTH ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EXTENT_DEPTH",
        e));

    a << ::xml_schema::as_double(*i.EXTENT_DEPTH ());
  }
}

void
simulation_ (::std::ostream& o,
             const ::simulation& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation_ (::std::ostream& o,
             const ::simulation& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::std::ostream& o,
             const ::simulation& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::xercesc::XMLFormatTarget& t,
             const ::simulation& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
simulation_ (::xercesc::XMLFormatTarget& t,
             const ::simulation& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::xercesc::XMLFormatTarget& t,
             const ::simulation& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::simulation_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
simulation_ (::xercesc::DOMDocument& d,
             const ::simulation& s,
             ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "simulation",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
simulation_ (const ::simulation& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "simulation",
      "",
      m, f));

  ::simulation_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const simulation& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // output
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "output",
        e));

    s << i.output ();
  }

  // parameters
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "parameters",
        e));

    s << i.parameters ();
  }

  // Boundary
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Boundary",
        e));

    s << i.Boundary ();
  }

  // particles
  //
  for (simulation::particles_const_iterator
       b (i.particles ().begin ()), n (i.particles ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particles",
        e));

    s << *b;
  }

  // Forces
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Forces",
        e));

    s << i.Forces ();
  }

  // cuboids
  //
  for (simulation::cuboids_const_iterator
       b (i.cuboids ().begin ()), n (i.cuboids ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cuboids",
        e));

    s << *b;
  }

  // discs
  //
  for (simulation::discs_const_iterator
       b (i.discs ().begin ()), n (i.discs ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "discs",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const output& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // baseName
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseName",
        e));

    s << i.baseName ();
  }

  // writeFrequency
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "writeFrequency",
        e));

    s << i.writeFrequency ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const parameters& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // tEnd
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tEnd",
        e));

    s << ::xml_schema::as_double(i.tEnd ());
  }

  // deltaT
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "deltaT",
        e));

    s << ::xml_schema::as_double(i.deltaT ());
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cutoff_radius",
        e));

    s << ::xml_schema::as_double(i.cutoff_radius ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const particles& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_double(i.z ());
  }

  // vel1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel1",
        e));

    s << ::xml_schema::as_double(i.vel1 ());
  }

  // vel2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel2",
        e));

    s << ::xml_schema::as_double(i.vel2 ());
  }

  // vel3
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel3",
        e));

    s << ::xml_schema::as_double(i.vel3 ());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_double(i.mass ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const Forces& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Force
  //
  if (i.Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Force",
        e));

    s << *i.Force ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const cuboids& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_double(i.z ());
  }

  // vel1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel1",
        e));

    s << ::xml_schema::as_double(i.vel1 ());
  }

  // vel2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel2",
        e));

    s << ::xml_schema::as_double(i.vel2 ());
  }

  // vel3
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel3",
        e));

    s << ::xml_schema::as_double(i.vel3 ());
  }

  // numPartX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numPartX",
        e));

    s << i.numPartX ();
  }

  // numPartY
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numPartY",
        e));

    s << i.numPartY ();
  }

  // numPartZ
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numPartZ",
        e));

    s << i.numPartZ ();
  }

  // thermal_v
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "thermal_v",
        e));

    s << ::xml_schema::as_double(i.thermal_v ());
  }

  // width
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "width",
        e));

    s << ::xml_schema::as_double(i.width ());
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << ::xml_schema::as_double(i.mass ());
  }

  // dimension
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dimension",
        e));

    s << i.dimension ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const discs& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x",
        e));

    s << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y",
        e));

    s << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z",
        e));

    s << ::xml_schema::as_double(i.z ());
  }

  // vel1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel1",
        e));

    s << ::xml_schema::as_double(i.vel1 ());
  }

  // vel2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel2",
        e));

    s << ::xml_schema::as_double(i.vel2 ());
  }

  // vel3
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vel3",
        e));

    s << ::xml_schema::as_double(i.vel3 ());
  }

  // distance_h
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "distance_h",
        e));

    s << ::xml_schema::as_double(i.distance_h ());
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << ::xml_schema::as_double(i.radius ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

